#!/usr/bin/env perl
use strict;
  

########################################
#
#  version 24: 
#  
#  chunk results and then meta-chunk
#  area_plot_speed
#  new manhattan plot
#  new areator
#  chrX
#  new gwascatalog
#  exclude refind: cat pi_sub/prephase_job_list_multi1 | awk '{print $3}' | sed 's/.*chr/chr/' | sed 's/.bed//' > refind.ex
#
#  version 32:
#   checkflip with fth
#
#
#  version 5:
#    with auto-het
#    with --addcov#
#
#
#
#  version 7:
#    for LISA
#
#  version 8:
#    fam testing for after-joinimp
#
#  version 9:
#    danerdir_long into week queue
#
#  version 10:
#    ldscore
#    prepare leave_one_out
#
#  version 11:
#    want to check for idin, addcov, idex (not implemeted yet)
#
#  version 12:
#    serial
#
#  version 13
#    plink2 also for dosages
#    --noldsc
#    error checking for result-files
#
#  version 14
#    --nolahunt
#
#  version 15
#    --fix some little things
#    --clumper into clump-navi3
#    --clumper out of --onlymeta and separate switch
#
#  version 16
#    danerdir_6: for covariates in trio data (important for conditional tests)
#
#  version 17
#    improvements for big datasets (danerdir_long and similar)
#
#  version 18
#    getting rid of pi_sub
#    checking --idin
#
#  verion 19
#    metaber6 with checks of consistency of SNPs.
#
#  version 20
#    metaber7 with detailed samplesize per SNP
#
#
########################
#  asked: actual sample size per SNP
#  check if mds file fits to famfiles ( I thoughts thats done but apparently not, see swapnil and run1 and run2)
####################
#
#######################################



### working on 35, stopped at after chucker........
### get the stuff at the end of onlymeta

### look for here working (2 spots)

#############################
# load utility functions
#############################

use FindBin;
use lib "$FindBin::Bin";
use Ricopili::Utils qw(trans);
use Ricopili::Version;




#my $version = "1.0.30";
my $progname = $0;
$progname =~ s!^.*/!!;
my $command_line = "$progname @ARGV";

my $s2gr = 300;
my $jmem = 3000; ### memory for puter imputation job
my $jmem_sm = 1000; ### memory for smaller job
my $jnum = 7; ### number of imputation job per node

my $spliha_n = 1500; ## split haplotypes with N individuals

my $best_lahunt = 5;

my $multithread1 = 4;
my $multithread2 = 8;

my $nj = 4;
my $phas = 0;

my $walltime = 1;

my $chr =0;
my $gmodel = 0;

my $rseed = 0;
my $info_txt = "";
#my $homedir = "/home/gwas";
my $rootdir = "";

my $iname = "" ;
my $pheno_file = "NOPHENO";

my $suminfo = "infosum_pos";
my $suminfo_n = "$suminfo.nsnps";
my $suminfo_r = "$suminfo.reffiles";
my $suminfo_s = "$suminfo.sorted";

my $job_bn_th = 1000;

my @ref_coll = ();

my $info_th = "0.1";

my $build_txt = "hg19";



#print "hmm\n";
#exit; 

## permutation 
## awk '{print $1,$2,int(2*rand())+1}' ....mds_cov > .....mds_cov.perm1
##

#my $hapmap_ref_root = "/home/gwas/pgc-samples/hapmap_ref/";
my $polyfrom_file = "";
my $danscore_file = "";
my $range_file = "";
my $polyto_file = "";
my $sepa = 1;


my $fth_th = 0.15;


use Sys::Hostname;
my $host = hostname;

my $serial = 0;

#my $broad = 1 if ($ENV{"DOMAINNAME"} =~ /broadinstitute/);


#############################
# read config file
#############################


my $hapmap_ref_root = &trans("hmloc");
#my $homedir = &trans("home");
my $qloc = &trans("queue");
my $i2loc = &trans("i2loc");
my $email = &trans("email");
my $loloc = &trans("loloc");
my $bcmd = &trans("batch_jobcommand");


###############################################

if ($bcmd eq "SERIAL") {
    $serial = 1;
    print "-----------------------------------------------------\n";
    print "switched on SERIAL mode because of configuration file\n";
}



#exit;

my $sec_freq = .2;  ## secure freq distance around 50%

my $r2th = .1;

my $wide_range = 1500000;
my $minthread = 0;

my $popname = "eur";
my $nohet_sw = 0;
my $prekno_file = "";

##### help message
my $usage = "
Usage : $progname [options]

version: $rp_version

 --test            testing with only one dosage file
 --chr INT         only one chromosome
 --help            print this text and exits
 --s2gr            chunk size, default=$s2gr

 --nj INT          number of jobs in one node, default: $nj (each gets 4GB of RAM)
 --walltime INT    walltime for imp-jobs : $walltime
 --mem INT         memory for puter-jobs, in MB, default $jmem
 --trio            for trio data.
 --triset STRING  for subset of trio datasets (can contain bimfiles)
 --idin STRING     ID inclusion list (before imputation, while ripping)

 --sep_pca         create and use a separate PCA for each cohort (will get better control over popstrat)
                     see more details below

 --sep_idin STRING use a different IDset than the separate 

 --mds STRING      mds-file (with studyindicator, (if necessary), 
                       NOMDS if no pcaer wished and analysis without covariates
 --coco STRING     comma separated PCA numbers

 --addcov STRING   additional covariates (be sure that ID names match the famfiles, all covariates in here will be used)
                   header is mandatory, starting with FID IID ....

 --pheno STRING    alternative pheno-file in 3rd column

 --strip           strip id-prefix when doing phenofiles
 --rseed INT       random seed, default: $rseed

 --cox             only conditional analysis on combined group, then exit

 --spliha INT      split haplotypes with N individuals
#  --chrX            only chr X

  --metaset STRING for subsets of meta datasets, especially for fores-plots (can contain bimfiles)

  --outname STRING name for outfiles (mandatory)
  --addout STRING  name for outfiles after imputation (different analysis runs)
  --allsw          take all SNPs in reffiles

  --model INT     genetic model in dosage phase
                     0 - allelic (default)
                     1 - dominant for first allele
                     2 - recessive for first allele
                     3 - heterocygote 


#  --nomega           do a meta and work from there, 
#                         must do with real big datasets
#  --nocon            do without conditional
#  --nocovar          analysis without covariates

  --reparea STRING  replicator out file with areas to show in each study
                     format: SNP,CHR,POS in each row.


#  --sfh FLOAT         secure frequency around 50% (default: $sec_freq)
#                                for checkflip
#  --fth FLOAT         frequency-diff to exclude SNPs, default $fth_th
#                                for checkflip


  --perm INT          INT permutations while danerdir
  --siperm INT        single permutation with seed INT

  --remeta FILE       print region plots and forest plots for replication data.

  --test              take only 1 daner-job-round for testing round.

  --wide INT          widerange in BP (default $wide_range)

  --cdg               cdg, currently the groups mdd, bip scz
#  --keep STRING       keep IDFILE

  --idex STRING       IDs to remove
  --idin STRING       IDs to include (does not work with sep_pca)

  --result FILE       start with result files, named in STRING, one each row
                         must have proper header in each file
                         still define a phase.
  --onlymeta          stop after meta-analysis while starting clump_nav2

  --xdf               do a metaber with xdf instead of weighted meta

  --r2th FLOAT        areator r2-threshold, default $r2th

  --prekno STRING     pre-known SNPs in first column
  --nocatalog         areaplots without catalog (without prekno)
  --mach              use miniMACH instead of Beagle

  --polyfrom STRING   ID-pt-file containing training set, creates then a danscore-file.
  --polyto STRING     ID-pt-file containing target set
  --score STRING      score - file
  --range STRING      range - file


  --bgscore           use best guess for scoring (way faster)

  --minthread INT     minimum multithreading

  --refiex            file containing refinds to exclude

  --bn_job INT        submit INT jobs at a time

  --popname STRING    population for clumping, right now: eur, eas, sas, amr, afr

  --regplot STRING    additional regplot file
  
###  --cond              conditional analysis on areator output

  --males          only use males, famfile needs to be right
  --females        only use females, famfile needs to be right

  --nohet          no het qq, manhattatn, etc

  --noclump          no clump if inlymeta

  --force1           do not exit if same fail, but do this only once


  --serial          no sending jobs to queue all in one run
                           -> usually only used for testing 
  --sepa INT        use INT number of parallel jobs during serial

  --sleep INT         sleep for INT seconds, try this if you think there is a race condition
                       (hints: stops a different steps, --serial works)
                       try using 5 seconds first.


  --noldsc          do not do ldscore (if problems there)
  --nolahunt        do not do lahunt (speeds up the pipeline)
  --gwclump         do genome wide clumping in the end (for scoring)

  --no_neff_filter  do not do Neff filter
  --info_th FLOAT   filter for info prior to meta-analysis, will not work on single cohort analysis
                        defaut $info_th
                        !!! use zero before period  !!!

  --debug             extended output

  ********
  uses puter and subchromosomes in reference
  ************


############################################################
### Instructions to run a \"--sep_pca\" postimp module when individual *mds files are already available:
#######################################

0) Create a \"danerjobdir_[OUT_NAME]\" and a \"pcaer_sep_sub\" subdirectories

1) Link *trans.mds files into \"danerjobdir_[OUT_NAME]\" and \"pcaer_sep_sub\", E.G.:

## while read ss; do ln -s /psych/ripke/scz/wave3/scz_phase3_imputation/batch123/HRC/pcaer_sep_sub/\${ss}_sr-qc.hg19.ch.fl.bgs.menv.trans.mds /stanley/ripke_storage/hla_imputation/CookHLA/impute_ricopili/mhc/1000G_REF/hg19/imp_HLA-1KG_ALL/mm4_oct23/pcaer_sep_sub/\${ss}_sr-qc_mhc.hg19.ch.fl.bgs.menv.trans.mds; done < study_list
## while read ss; do ln -s /psych/ripke/scz/wave3/scz_phase3_imputation/batch123/HRC/pcaer_sep_sub/\${ss}_sr-qc.hg19.ch.fl.bgs.menv.trans.mds /stanley/ripke_storage/hla_imputation/CookHLA/impute_ricopili/mhc/1000G_REF/hg19/imp_HLA-1KG_ALL/mm4_oct23/danerjobdir_PGC_SCZ_w3_75_HLA-1KG_ALL_mm4_run1/\${ss}_sr-qc_mhc.hg19.ch.fl.bgs.menv.trans.mds; done < study_list

with \"study_list\" file being:
scz_bep1b_eur
scz_braz2_eur
scz_celso_eur
etc...


2) Link *overworked.p_assoc.txt files into \"danerjobdir_[OUT_NAME]\" and \"pcaer_sep_sub\":
## while read ss; do ln -s /psych/ripke/scz/wave3/scz_phase3_imputation/batch123/HRC/pcaer_sep_sub/$\{ss}_sr-qc.hg19.ch.fl.bgs.menv.mds.overworked.p_assoc.txt /stanley/ripke_storage/hla_imputation/CookHLA/impute_ricopili/mhc/1000G_REF/hg19/imp_HLA-1KG_ALL/mm4_oct23/pcaer_sep_sub/\${ss}_sr-qc_mhc.hg19.ch.fl.bgs.menv.mds.overworked.p_assoc.txt; done < study_list
## while read ss; do ln -s /psych/ripke/scz/wave3/scz_phase3_imputation/batch123/HRC/pcaer_sep_sub/\${ss}_sr-qc.hg19.ch.fl.bgs.menv.mds.overworked.p_assoc.txt /stanley/ripke_storage/hla_imputation/CookHLA/impute_ricopili/mhc/1000G_REF/hg19/imp_HLA-1KG_ALL/mm4_oct23/danerjobdir_PGC_SCZ_w3_75_HLA-1KG_ALL_mm4_run1//\${ss}_sr-qc_mhc.hg19.ch.fl.bgs.menv.mds.overworked.p_assoc.txt; done < study_lis

3) Rename your \"*.covfiles\" file into \"[OUT_NAME].covfiles\" and put inside \"danerjobdir_[OUT_NAME]\".

4) A *.menv.mds_cov.idin file is also needed inside the \"danerjobdir_[OUT_NAME]\" diretory to extract non-overlapping individuals. (used with the \"--idin\" flag)



 created by Stephan Ripke 2009 at MGH, Boston, MA
 
";


use Getopt::Long;
GetOptions( 

    "s2gr=i"=> \ $s2gr,
    "chr=i"=> \ $chr,
    "nj=i"=> \ $nj,
    "trio"=> \my $trio,
    "triset=s"=> \my $trioset_file,

    "metaset=s"=> \my $metaset_file,
    "remeta=s"=> \my $remeta,
    "test"=> \my $test,
    "help"=> \my $help,
    "mach"=> \my $mach_sw,
    "mds=s"=> \my $mds_name,
    "sep_pca"=> \my $sep_pca,
    "sep_idin=s"=> \my $sep_idin_str,
    "addcov=s"=> \my $addcov_name,
    "idex=s"=> \my $idex_name,
    "idin=s"=> \my $idin_name,

    "coco=s"=> \my $mds_cols,
    "allsw"=> \my $allsw,
    "cox"=> \my $cox,
    "outname=s"=> \my $outname,
    "serial"=> \my $serial_sw,
    "sepa=i"=> \$sepa,

    "sleep=i"=> \my $sleep_sw,

    "walltime=i"=> \ $walltime,
    "mem=i"=> \ $jmem,
    "model=i" => \$gmodel,
    "pheno=s"=> \$pheno_file,
    "strip"=> \my $strip_pt,
#    "keep=s"=> \my $keep,
    "addout=s"=> \my $addout,
    "nocovar"=> \my $nocovar,
    "reparea=s"=> \my $reparea,
    "result=s"=> \my $result_name,
    "onlymeta"=> \my $onlymeta,
    "noclumper"=> \my $noclumper,
#    "nomega"=> \my $nomega_sw,
#    "nocon"=> \my $nocon,
    "xdf"=> \my $xdf,
    "sfh=f"=> \$sec_freq,
    "fth=f"=> \$fth_th,
    "perm=i"=> \my $permut,
    "siperm=i"=> \my $siperm,
    "cdg"=> \my $cdg,
    "rseed=i"=> \$rseed,
    "r2th=f"=> \$r2th,
    "wide=i"=> \$wide_range,
    "prekno=s"=> \$prekno_file,
    "popname=s"=> \$popname,
    "refiex=s"=> \my $refiex_file,
    "score=s"=> \$danscore_file,
    "bgscore"=> \my $bgscore,
    "range=s"=> \$range_file,
    "polyfrom=s"=> \$polyfrom_file,
    "polyto=s"=> \$polyto_file,
    "minthread=i"=> \$minthread,
    "bn_job=i"=> \$job_bn_th,
    "spliha_n=i"=> \$spliha_n,
    "regplot=s"=> \my $regplot_file,

    "males"=> \my $males,
    "females"=> \my $females,
    "nohet"=> \my $nohet,
   "force1"=> \my $force1,
   "noldsc"=> \my $noldsc,
    "nolahunt"=> \my $nolahunt,
    "no_neff_filter"=> \my $no_neff_filter,
    "gwclump"=> \my $gwclump,
    "info_th=s"=> \$info_th,
    "debug"=> \my $debug,
    "nocatalog"=> \my $nocatalog,
#    "cond"=> \my $cond,

#    "chrX"=> \my $chrX,
    );


if ($serial_sw) {
    $serial = 1;
}




$popname = uc $popname;

if ($nohet) {
  $nohet_sw = 1;
}


if ($sleep_sw) {
  print "sleeping for $sleep_sw seconds (only use if suspect of race condition)\n";
  sleep ($sleep_sw);
}

my $no_neff_filter_txt = "";
if ($no_neff_filter) {
    $no_neff_filter_txt = "--no_neff_filter";
}




############################################################
## testing binaries
##############################################################
my @test_scripts;



my $metaber_script = "metaber7";               ### my.pipeline_tar
my $daner_script = "danerdir_6";               ### my.pipeline_tar
my $danscore_result_script = "danscore_result_3";          ### my.pipeline_tar
my $chunker_script = "chunker2";                ### my.pipeline_tar
my $danerhet2p_script = "my.daner_het2p";      ### my.pipeline_tar
my $topfilter_script = "topfilter";            ### my.pipeline_tar
my $areator_script = "areator_dan9";           ### my.pipeline_tar
my $areaplot_script = "area_plot_16_speed";    ### my.pipeline_tar
my $forestplot_script = "forest_plot8";        ### my.pipeline_tar
my $manhattanplot_script = "manhattan_p4";     ### my.pipeline_tar
my $manhattanplot2_script = "manhattan_plot2";  ### my.pipeline_tar
my $qqplot_script = "qqplot_5";                ### my.pipeline_tar
my $lahunt_script = "lahunt_9";                ### my.pipeline_tar
my $ldsc_script = "my.ldsc2";                ### my.pipeline_tar
my $blueprint_script = "blueprint";            ### my.pipeline_tar
#my $clumpnavi_script = "clump_navi";           ### my.pipeline_tar
my $clumpnavi2_script = "clump_nav3";          ### my.pipeline_tar
my $shrinkpdf_script = "shrinkpdf";            ### my.pipeline_tar
my $comp1mhc_script = "comp1mhc2";             ### my.pipeline_tar
#my $comp1mhc1_script = "comp1mhc";    
my $comp1mhcreg_script = "comp1mhc_reg";       ### my.pipeline_tar
my $pdfjoin_script = "pdfjoin";                ### my.pipeline_tar
my $pdfnup_script = "pdfnup";                  ### my.pipeline_tar
my $senddropbox_script = "send_dropbox";       ### my.pipeline_tar
my $linksub_script = "my.linksub";             ### my.pipeline_tar
my $sb_script = "sb";                          ### my.pipeline_tar
my $placeholder_script = "placeholder";        ### my.pipeline_tar
my $numbers_script = "my.numbers";             ### my.pipeline_tar
my $pdflatex_script = "pdflatex";              ### my.pipeline_tar
my $mystart_script = "my.start_job";           ### my.pipeline_tar
my $replicator_script = "replicator13";        ### my.pipeline_tar
my $replicmeta_script = "replicator_meta11";   ### my.pipeline_tar
my $damecat_script = "my.dameta_cat";          ### my.pipeline_tar
my $plot_or_reg_script = "plot_or_regressions"; ### my.pipeline_tar

my $mutt_script = "mail";

push @test_scripts, $pdflatex_script ;
push @test_scripts, $metaber_script ;
push @test_scripts, $daner_script ;
push @test_scripts, $danscore_result_script ;
push @test_scripts, $chunker_script ;
push @test_scripts, $danerhet2p_script ;
push @test_scripts, $topfilter_script ;
push @test_scripts, $areator_script ;
push @test_scripts, $areaplot_script ;
push @test_scripts, $forestplot_script ;
push @test_scripts, $manhattanplot_script ;
push @test_scripts, $manhattanplot2_script ;
push @test_scripts, $qqplot_script ;
push @test_scripts, $lahunt_script ;
push @test_scripts, $ldsc_script ;
push @test_scripts, $blueprint_script ;
#push @test_scripts, $clumpnavi_script ;
push @test_scripts, $clumpnavi2_script ;
push @test_scripts, $shrinkpdf_script ;
push @test_scripts, $comp1mhc_script ;
push @test_scripts, $damecat_script ;
#push @test_scripts, $comp1mhc1_script ;
push @test_scripts, $comp1mhcreg_script ;
push @test_scripts, $pdfjoin_script ;
push @test_scripts, $pdfnup_script ;
push @test_scripts, $senddropbox_script ;
push @test_scripts, $linksub_script ;
push @test_scripts, $sb_script ;
push @test_scripts, $placeholder_script ;
push @test_scripts, $numbers_script ;
push @test_scripts,  $mystart_script;



$rp_header =~ s/MODULE/postimp_navi /;

print "$rp_header\n";


print ".......testing necessary binaries....\n" if ($debug);
my @miss_scripts;


#my $err_scr = 0;
foreach my $scr_name (@test_scripts) {
    my $scr_path = '';
    
    for my $path ( split /:/, $ENV{PATH} ) {
	if ( -f "$path/$scr_name" && -x _ ) {
	    print "$scr_name\tfound in $path\n" if ($debug);
	    $scr_path = "$path/$scr_name";
	    last;
	}
    }
    if ( $scr_path eq  '') {
	push @miss_scripts, "cp /home/unix/sripke/bin/$scr_name ./\n";
	print "!!Error!! : No $scr_name command available\n" ;
    }
 
}

#exit;


if (@miss_scripts > 0) {
  if (-e "get_scripts_on_broad.txt") {
    print "please remove this file and restart: get_scripts_on_broad.txt\n";
  }
  die $! unless open FILE1, "> get_scripts_on_broad.txt";
  foreach (@miss_scripts) {
    print FILE1 "$_";
  }
  close FILE1;


  print "exiting now -> have a look at get_scripts_on_broad.txt\n";
  exit;

}







print ".......testing email program....\n" if ($debug);
my $noti = 1;
my $err_scr = 0;
{
    my $scr_path = '';
    
    for my $path ( split /:/, $ENV{PATH} ) {
	if ( -f "$path/$mutt_script" && -x _ ) {
	    print "$mutt_script\tfound in $path\n" if ($debug);
	    $scr_path = "$path/$mutt_script";
	    last;
	}
    }
    unless ( $scr_path ) {

	print "!!Warning!! : No $mutt_script command available, trying mutt\n"  if ($debug);

	$mutt_script = "mutt";
	for my $path ( split /:/, $ENV{PATH} ) {
	    if ( -f "$path/$mutt_script" && -x _ ) {
		print "$mutt_script\tfound in $path\n" if ($debug);
		$scr_path = "$path/$mutt_script";
		last;
	    }
	}
	unless ( $scr_path ) {
	    #	    $err_scr = 1;
	    print "!!Warning!! : No $mutt_script command available, no email notifications\n";
	    $noti = 0;

	    
	}
    }
 
}
die if $err_scr == 1;


print "....all necessary binaries found....\n" if ($debug);
print "------------------------------------\n" if ($debug);
#push @scripts,"id_tager_3";



#####################################
# "testing environment variable rp_perlpackages
####################################

print "testing environment variable rp_perlpackages....\n" if ($debug);
unless (exists $ENV{rp_perlpackages}) {
    print "Error: no environment variable for perl-packages, please re-install ricopili and make sure to follow all instructions\n";
    print "------------------------------------\n";
    exit;
}
print "....all set....\n" if ($debug);
print "------------------------------------\n" if ($debug);










my $nomega_sw = 1;

srand($rseed);

my $nomega = 0;
$nomega = 1 if ($nomega_sw);
$nomega = 1 if ($result_name);

my $machstr = "";
$machstr = "--mach" if ($mach_sw);

die $usage if $help;

die $usage unless $outname;


my $xdf_txt = "";
$xdf_txt = "--xdf" if ($xdf);


#my ($xsnp,$xchr,$xbeg,$xend);
#($xsnp,$xchr,$xbeg,$xend)= split ',', $xareastr if ($xareastr);





my %refiex;
if ($refiex_file) {
    print "read $refiex_file...\n" if ($debug);
    die $!." <$refiex_file>" unless open IN, "< $refiex_file";
    while (my $line = <IN>){
	chomp($line);
	$refiex{$line} = 1;
#	print "$line\n";
    }
    close IN;
    print "...finished\n" if ($debug);

}








#my $impute_dir = "pi_sub";


#my $postimp_dir = "$impute_dir/postimp_data";


if ($trio) {
    die "please use size (--s2gr) compatible for trios, keep in mind, size will be n*4" unless ($s2gr % 3 == 0 || $s2gr > 200);
}




sub fisher_yates_shuffle {
    my $deck = shift;  # $deck is a reference to an array
    my $i = @$deck;
    while ($i--) {
	my $j = int rand ($i+1);
	@$deck[$i,$j] = @$deck[$j,$i];
    }
}


#####################################
# print array to file
####################################

sub a2file {
    my ($file, @lines)=@_;
    die $! unless open FILE, "> $file";
    foreach (@lines){
	print FILE $_;
    }
    close FILE;
}


###################################################
###  system call with test if successfull
###################################################
sub mysystem(){
    my ($systemstr)="@_";
    system($systemstr);
    my $status = ($? >> 8);
    die "----\n->system call failed: $status\ncommand: $systemstr\n" if ($status != 0);
}

###################################################
###  system call with test if successfull
###################################################
sub mysystem_nodie(){
    my ($systemstr)="@_";
    system($systemstr);
    my $status = ($? >> 8);
    print "----\n->Warning: system call problem: $status\ncommand: $systemstr\n" if ($status != 0);
}


##########################################
# subroutine to split a plink-output-line
##########################################

sub split_line {
    my ($line)=@_;
    chomp($line);
    $line =~ s/^[\s]+//g;
    my @cols=  split /\s+/, $line;
}

##########################################
# subroutine to split a plink-output-line with references
##########################################

sub split_line_ref {
    my ($line)=${$_[0]};
    chomp($line);
    $line =~ s/^[\s]+//g;
    my @cols=  split /\s+/, $line;
    \@cols;
}





#####################################
# print array to file with newline
####################################

sub a2filenew {
    my ($file, @lines)=@_;
    die $! unless open FILE, "> $file";
    foreach (@lines){
	print FILE "$_\n";
    }
    close FILE;
}


#####################################
# append array to file with newline
####################################

sub a2filenew_app {
    my ($file, @lines)=@_;
    die "$!: $file" unless open FILE, ">> $file";
    foreach (@lines){
	print FILE "$_\n";
    }
    close FILE;
}

#####################################
# subroutine to count lines of a file
#####################################

sub count_lines {
    my ($file)=@_;
    my $lc=0;
    die "$file: ".$! unless open FILE, "< $file";
    while (<FILE>){
	$lc++;
    }
    close FILE;
    $lc;
}



#####################################
# subroutine to re-invoke this script
#####################################

#sub reinvo_b {
#    my ($message, $wt_file)=@_;
#    my $now = localtime time;
#    my $old_cmd = `tail -3 $homedir/postimp_navi_35_test | head -1`;#

#    my $message_part = $info_txt."\t$message";
#    $message = $info_txt."\t$message\t$now";

#    &a2filenew_app("$homedir/postimp_navi_35_test",$message);
#    die "2 times already" if ($old_cmd =~ /$message_part/);
#    chdir "$rootdir" or die "something strange";
#    if ($qloc eq "bsub") {#
#	$wt_file =~ s/.*blueprint_joblist_file-//;
#    }

#    my $sys_re = "blueprint --njob $job_bn_th -b \"$command_line\" --wa 4 --di -j --fwt $wt_file --na _if_$outname";
#    print "$sys_re\n";
#    &mysystem ($sys_re);
#    exit;

#}


#####################################
# send jobs to cluster and also send navi again
#####################################

my $sjadir = "";
my $sjaweek = 0;
my $sjaname = "";
my $sjarow = "";
my @sjaarray;
my $sjamem = 0;
my $sjatime = -1;
my $sjamaxjobs = 30000;
#my $sjainfofile = "$homedir/impute_dir_info";
my $sjainfofile = "$loloc/postimp_navi_info";
unless (-e $sjainfofile) {
    print "log-file ($sjainfofile) is not existing\n";
    print "please check loloc in ~/ricopili.conf\n";
    exit;
}
my $sjainfotxt = "";
my $sjamulti = 0;


sub send_jobarray {

    die "send_jobarray with undefined variables, dir" if ($sjadir eq "");
    die "send_jobarray with undefined variables, name" if ($sjaname eq "");
    die "send_jobarray with undefined variables, array" if (@sjaarray == 0);
    die "send_jobarray with undefined variables, mem" if ($sjamem == 0);
    die "send_jobarray with undefined variables, time" if ($sjatime < 0);
    die "send_jobarray with undefined variables, info" if ($sjainfotxt eq "");


    print "Running job: $sjaname\n";


    my $now = localtime time;
    $now =~ s/ /_/g;


    if ($sjaname eq "finished") {

	my $fini_message ;
	$fini_message .= "\n\n##################################################################\n";
	$fini_message .= "##### CONGRATULATIONS: \n";
	$fini_message .= "##### rp_pipeline_postimp finished successfully:\n";
	$fini_message .= "##### $sjainfotxt\n";
	$fini_message .= "##### have a look at the distributions subdir for output files\n";
	$fini_message .= "##### have a look at the wiki page for more details\n"; 
	$fini_message .= "##### https://sites.google.com/a/broadinstitute.org/ricopili/\n";
	$fini_message .= "##################################################################\n";
	print "$fini_message\n";

	
	die $! unless open SUC, "> success_file";
	print SUC $fini_message."\n";
	close SUC;

	if ($noti == 1) {
	    
	    my $sys_email = 'cat success_file | '.$mutt_script.' -s RP_postimp_finished '.$email;
	    print "$sys_email\n";
	    &mysystem ($sys_email) ;

	}
	my $sjarow      = $sjainfotxt."\t$sjaname\t$now";
	&a2filenew_app("$sjainfofile",$sjarow);


	exit;

    }

    if ($sjaname eq "paused") {

	my $fini_message ;
	$fini_message .= "\n\n##################################################################\n";
	$fini_message .= "##### rp_pipeline_postimp paused\n";
	$fini_message .= "##### $sjainfotxt\n";
	$fini_message .= "##### please read and follow instructions above then restart\n";
	$fini_message .= "##### have a look at the wiki page for more details\n"; 
	$fini_message .= "##### https://sites.google.com/a/broadinstitute.org/ricopili/\n";
	$fini_message .= "##################################################################\n";
	print "$fini_message\n";

	
	die $! unless open SUC, "> success_file";
	print SUC $fini_message."\n";
	close SUC;

	if ($noti == 1) {
	    
	    my $sys_email = 'cat success_file | '.$mutt_script.' -s RP_postimp_paused '.$email;
	    print "$sys_email\n";
	    &mysystem ($sys_email) ;

	}
	my $sjarow      = $sjainfotxt."\t$sjaname\t$now";
	&a2filenew_app("$sjainfofile",$sjarow);


	exit;

    }
    



    chdir ($sjadir);
    my $jobfile = "$sjaname.job_list";
    while (-e $jobfile) {
	$jobfile .= ".s";
    }
    &a2filenew ($jobfile, @sjaarray);


#    print "$sjadir\n";
#    print "$jobfile\n";
#    print "N:".@sjaarray."\n";
    
#    print "sleep\n";
#    sleep(10);

    $walltime = $sjatime;
    my $nsja = @sjaarray;

    my $nsja_loc = $nsja;
    if ($nsja_loc > 30000) {
	$nsja_loc = 30000;
    }

    my $multi_txt = "";
    if ($sjamulti > 0) {
	$multi_txt = "--multi $nsja_loc,$sjamulti";
    }

    ### with array
    my $sja_week_str = "";
    if ($sjaweek > 0) {
	$sja_week_str = "--week 1";
    }



    my $old_cmd = `tail -1 $sjainfofile | head -1`;
    my $nsja_txt = sprintf "%06d",$nsja;
    my $sjacontent = "$sjaname.".$nsja_txt;
    my $sjarow_part = $sjainfotxt."\t$sjacontent";
    my $sjarow      = $sjainfotxt."\t$sjacontent\t$now";
#    $message = $info_txt."\t$message\t$now";

#    if ($debug) {
#	print "exit before danerjob\n";
#	exit;
#    }
    &a2filenew_app("$sjainfofile",$sjarow);

    if ($old_cmd =~ /$sjarow_part/) {


	unless ($force1 ){
	    my $err_message ;
	    $err_message .= "##################################################################\n";
	    $err_message .= "##### Error: \n";
	    $err_message .= "##### step $sjaname has been done repeatedly without any progress\n";

	    $err_message .= "##### postimp pipeline stopped\n";
	    $err_message .= "##### $sjainfotxt\n";
	    $err_message .= "##### if reason does not appear obvious\n";
	    $err_message .= "##### have a look at the wiki page\n"; 
	    $err_message .= "##### https://sites.google.com/a/broadinstitute.org/ricopili/\n";
	    $err_message .= "##### or contact the developers\n";
	    $err_message .= "##### version: $rp_version\n";
	    $err_message .= "##################################################################\n";
	    print "$err_message\n";

	    die $! unless open ERR, "> error_file";
	    print ERR $err_message."\n";
	    close ERR;


	    if ($noti == 1) {

		&mysystem ('cat error_file | '.$mutt_script.' -s RP_postimp_error '.$email) ;

	    }
#	    unless ($serial) {
		exit;
#	    }
	}



    }


    
    #################################
    ## starting the job array
    ##################################
    if ($serial) {

	print "starting step $sjaname with ".@sjaarray." jobs\n" if ($debug);
	print "running up to $sepa parallel jobs.\n" if ($debug);


	my $jc = 1;
#	my $job_str = "";
	my @job_sepa_arr;

	foreach (@sjaarray) {
	    print "running job $jc...\n" if ($debug);
	    push @job_sepa_arr, "$_ &";
#	    $job_str .= "$_ & \n";

	    if ($jc % $sepa == 0) {
		push @job_sepa_arr, "wait";
		#		$job_str .= "wait\n";
		my $sepa_file = "$sjaname.sepa.$jc";
		&a2filenew ($sepa_file,@job_sepa_arr);
		print "sepa_file: ".$sepa_file."\n" if ($debug);
		&mysystem("chmod u+x $sepa_file");
		&mysystem("./$sepa_file");
		@job_sepa_arr = ();
	    }
	    $jc++;
	    
	}

	if (@job_sepa_arr > 0) {
	    $jc--;
	    push @job_sepa_arr, "wait";
	    
	    my $sepa_file = "$sjaname.sepa.$jc";
	    &a2filenew ($sepa_file,@job_sepa_arr);
	    print "sepa_file: ".$sepa_file."\n" if ($debug);
	    &mysystem("chmod u+x $sepa_file");
	    &mysystem("./$sepa_file");
	}

		
    }
    else { 
	my $sys_loc = "$blueprint_script $sja_week_str --noerr --njob $nsja_loc --array $jobfile --wa $sjatime --mem $sjamem --j --na $jobfile $multi_txt";
#	print "$sys_loc\n";
#	exit;	

	&mysystem ($sys_loc);
    }




    
    $command_line =~ s/--force1//;



    my $wt_file = "$sjadir/j.$jobfile.id";
    chdir "$rootdir" or die "something strange";
    
    

    if ($serial) {
	my $sys_re = "$command_line";
	&mysystem ($sys_re);
	exit;
    }
    else {
	my $sys_re = "$blueprint_script --njob $job_bn_th -b \"$command_line\" --wa 2 --di -j --fwt $wt_file --na _pi_$outname";
	&mysystem ($sys_re);
    }


    print "------------------------------------------------------------\n";
    print "$nsja jobs successfully submitted\n";
    print "please see tail of $sjainfofile for regular updates\n";
    print "also check bjobs -w for running jobs\n";
    print "possibly different command on different computer cluster: e.g. qstat -u USER\n";
    print "you will be informed via email if errors or successes occur\n";
    print "------------------------------------------------------------\n";


    exit;


}




#####################################
# subroutine to re-invoke this script
#####################################

#sub reinvo_b_week {
#    my ($message, $wt_file)=@_;
#    my $now = localtime time;
#    my $old_cmd = `tail -3 $homedir/impute_dir_info | head -1`;

#    my $message_part = $info_txt."\t$message";
#    $message = $info_txt."\t$message\t$now";

#    &a2filenew_app("$homedir/impute_dir_info",$message);
#    die "2 times already" if ($old_cmd =~ /$message_part/);
#    chdir "$rootdir" or die "something strange";
#    if ($qloc eq "bsub") {#
#	$wt_file =~ s/.*blueprint_joblist_file-//;
#    }

#    &mysystem ("blueprint --week 1 --njob $job_bn_th -b \"$command_line\" --wa 10 --di -j --fwt $wt_file --na _if_$outname");
#    exit;

#}



##############################################
##############################################
#############  BEGIN
##############################################
##############################################


use Cwd;
use File::Path;
$rootdir = &Cwd::cwd();
$sjainfotxt = "$rootdir\t$command_line";






#################################################
## prepare meta-sets
###################################################


my %metaset;
my @metaset_names;
my %metaset_bimfli;
if ($metaset_file){
    die $!." <$rootdir/$metaset_file>" unless open IN, "< $rootdir/$metaset_file";
    while (my $line = <IN>){
	my @cells = &split_line($line);
	$cells[1] =~ s/.bim$//;
	$cells[1] .= ".ch.fl";
	$metaset{$cells[1]} = $cells[0];
	push @metaset_names, $cells[0];
    }
    close IN;
}


################################################
### set info text
####################################################


$info_txt = "command:\t\"$command_line\"\tdir:\t$rootdir";







############################################################
### refind array
#############################################################

my @refind_arr;
my $refdir;


unless (-e "reference_info") {
    print "Error: no reference_info, please rerun impute_navi or copy it over from the original imputation directory\n";
    print "(the first row points to the reference directory the following rows define the genomic chunks)\n";
    exit;
}
else {
    die $! unless open REF, "< reference_info";
    my $line = <REF>;
    chomp($line);
    $refdir = $line;
    while ($line = <REF>){
	chomp($line);
	unless (exists $refiex{$line}) {
	    push @refind_arr, $line;
	}
    }
    close FAMI;
    if ($refdir eq "/home/pgcdac/DWFV2CJb8Piv_0116_pgc_data/HRC_reference.r1-1/"){
	print "Warning: - if you use this on SNELLIUS please stop (ctrl-C) and\n";
	print "           change reference-directory (first row) in file reference_info\n";
	print "           from /home/pgcdac/DWFV2CJb8Piv_0116_pgc_data/HRC_reference.r1-1/\n";
	print "           to /gpfs/work5/0/pgcdac/imputation_references/HRC_reference.r1-1/\n";
	print "         - if you use this on LISA just wait 5 sec\n";
	sleep(5);
    }
	            
}


my $Xchr = 0;
if ($refdir =~ /chr23/) {
    print "chr23 found\n" if ($debug);
    $Xchr = 1;
}

$refdir =~ s!/home/radon01/sripke/bakker_ripke/hapmap_ref!/psych/genetics_data/ripke/references_outdated/hapmap_ref!;

unless (-d $refdir) {
    print "Error: Reference Directory ($refdir) does not exist\n" if ($debug);
    print "please check first row in file reference_info\n" if ($debug);
    exit;
}

my %ref_hash;
if (-e "$refdir/reference_templ") {
    print "new format (reference_template) found.\n" if ($debug);
    die unless open IN, "< $refdir/reference_templ";
    while (my $line = <IN>) {
	my @cells = &split_line($line);
	$ref_hash{$cells[0]} = $cells[1];
    }
    if ($ref_hash{"build"} eq "hg38") {
	print "seems to be a build hg38\n";
#	sleep(2);
#	$hg38_sw = 1;
	$build_txt = "hg38";
#	$buigue_flag = "--lift38";
#	exit;
    }    
    
#    $suminfo_s_v2_sw = 1;
#    $suminfo_s_v2 = $ref_hash{"out_template"};
}


##########################################
## with new population ancestry directory
#########################################



if (-e "$refdir/pop_$popname") {

    $refdir = "$refdir/pop_$popname";
    print "found ancestry specific reference data for clumping and such: $refdir\n" if ($debug);



    my @gwascat_files = `ls -t $refdir/gwascatalog.*.rp.txt`;
    if (@gwascat_files == 1) {
	print "using as gwas catalog file: ".$gwascat_files[0]."\n" if ($debug);
	$prekno_file = $gwascat_files[0];
	chomp($prekno_file)
#	$prekno_txt = "--prekno $prekno_file";
    }
#    sleep(3);

}
#sleep(10);



###################################
### areator directories
###################################



my $areat_refdir = $refdir;
my $areat_diffdir = $refdir;
#print "$areat_refdir\n";



if ($areat_diffdir =~ /subchr&/ || $areat_diffdir =~ /subchr\/&/) {

    $areat_diffdir =~ s/subchr/$popname/;


    if (-e $areat_diffdir) {
	$areat_refdir = $areat_diffdir;
	print "using different subset for clumping: $areat_refdir\n" if ($debug);
	sleep (2);
	#    $refdir = $areat_eurdir;
    }
}




############################################################
### datasets
#############################################################

my @bimfli_files;

######### define dasudir
my $dasudir = "$rootdir/dasu";


my $bgdir = "$rootdir/cobg_dir_genome_wide";


###################################################
### separate PCA preparation
#####################################################

my $seppcadir = "$rootdir/pcaer_sep_sub";
unless (-e $seppcadir) {
    &mysystem ("mkdir $seppcadir");
}





unless (-e "datasets_info") {
    print "warning: no datasets_info, create one with all datasets\n" if ($debug);
    my @files = ();
    opendir(DIR, ".") || die "can't opendir .: $!";
    @files = readdir(DIR);
    closedir DIR;
    my @bim_files = grep {/bim$/} @files;
    die $! unless open BF, "> datasets_info.tmp";
    foreach (@bim_files) {
	my $bitemp = $_;
	$bitemp =~ s/.bim$//;

	print "bitemp: $bitemp\n" if ($debug);
	my $dasudir_loc_qc1 = "$dasudir"."qc1_$bitemp";
	$dasudir_loc_qc1 .= ".$build_txt.ch.fl";
#	print "start: $dasudir_loc_qc1  \n";
	
	unless (-e $dasudir_loc_qc1) {
	    my $tmpdir = $dasudir_loc_qc1;

	    $tmpdir =~ s/.$build_txt.ch.fl/.ch.fl/;
	    if (-e $tmpdir) {
		print "found old format: $tmpdir\n" if ($debug);
		$bitemp .= ".ch.fl";
	    }
	    else {
		print "not old and not new format: $tmpdir\n" if ($debug);
	    }
	}
	else {
	    $bitemp .= ".$build_txt.ch.fl";
	}
	print BF "$bitemp\n";
    }
    close BF;

    &mysystem ("cp datasets_info.tmp datasets_info");



}

#exit;
#else {

die $! unless open BF, "< datasets_info";
while (my $line = <BF>){
    chomp($line);
    push @bimfli_files, $line;
    unless ($line =~ /.$build_txt.ch.fl$/) {
	if ($line =~ /.ch.fl$/) {
	    print "Warning: old datasets_info: $line\n" if ($debug);
#	    exit;
	}
	else {
	    print "Error: something wrong with datasets_info, please remove this file and rerun\n";
	    exit;
	}
    }

}
close BF;

if (@bimfli_files == 1) {
    print "only one dataset to analyze, removing heterogeneity test\n" if ($debug);
    $nohet_sw = 1;
}
#}


############################################################
### empty
#############################################################

my %empty_files;
unless (-e "empty_info") {
    &mysystem ("touch empty_info");
    print "warning: no empty_info, created an empty one\n" if ($debug);
#    exit;
}
else {
    die $! unless open EM, "< empty_info";
    while (my $line = <EM>){
	chomp($line);
	$empty_files{$line} = 1;
    }
    close EM;
}




######## trioset, needs to be checked.
my %trioset_bimfli;  ## not used yet
my %trioset;  ## not used yet


if ($trioset_file){
    die $!." <$rootdir/$trioset_file>" unless open IN, "< $rootdir/$trioset_file";
    while (my $line = <IN>){
	my @cells = &split_line($line);
	$cells[0] =~ s/.bim$//;
	$cells[0] =~ s/.fam$//;

	$trioset{$cells[0].".ch.fl"} = 1;
	$trioset{$cells[0].".$build_txt.ch.fl"} = 1;

	
#	$cells[0] .= ".$build_txt.ch.fl";
#	$trioset{$cells[0]} = 1;


#	print "$cells[0] is triodata\n";
    }
    close IN;
}

foreach my $bifi (@bimfli_files) {
    $bifi =~ s/.bim$//;
#    print "testing $bifi\n";
#    $bifi =~ s/.ch.fl$//;
    if (exists $trioset{$bifi}){
	$trioset_bimfli{$bifi} = 1;
#	print "found $bifi\n" ;
    }
    else {
#	print "didn't $bifi\n" ;
    }

}
#exit;





###################################
### create submds
###################################

my $mds_name_sub = "$mds_name.sub";
my $mds_age = -M $mds_name;

unless ($sep_pca) {
    unless ($result_name){
	if ($mds_cols eq "ALL") {
	    &mysystem ("cp $mds_name $mds_name_sub");
	}
	else {
	    if ($mds_name ne "NOMDS") {
		unless (-e $mds_name) {
		    print "Error: mds-file <$mds_name> is not existing\n";
		    if ($mds_name eq "") {
			print "if you want to run analysis without covariates, use --mds NOMDS\n";
			exit;
		    }
		}
		unless (-e $mds_name_sub) {
		    die $!." <$mds_name>" unless open MDSI, "< $mds_name";
		    die $! unless open MDSO, "> $mds_name_sub";
		    
		    my @mds_arr = split ',' ,$mds_cols;
		    #print "@mds_arr\n";
		    my $line = <MDSI>;
		    my @cells = &split_line($line);
		    
		    foreach (2..$#cells){
			push @mds_arr, ($_-2) if ($cells[$_] =~ /^st/);
			push @mds_arr, ($_-2) if ($cells[$_] =~ /SCORE/);
		    }
		    print MDSO "$cells[0]";
		    print MDSO "\t$cells[1]";
		    

		    
		    foreach (@mds_arr){
			my $cn = $_+2;
			print MDSO "\t$cells[$cn]";
		    }
		    print MDSO "\n";
		    
		    while (my $line = <MDSI>){
			my @cells = &split_line($line);
			
			print MDSO "$cells[0]";
			print MDSO "\t$cells[1]";
			
			foreach (@mds_arr){
			    my $cn = $_+2;
			    print MDSO "\t$cells[$cn]";
			}
			
			print MDSO "\n";
		    }
		    
		    
		    close MDSI;
		    close MDSO;
		}
		else {
		    my $sub_age = -M $mds_name_sub;
		    die "sub is older than mds-file" if ($sub_age > $mds_age);
		}
	    }
	}
    }

}

###################################
### create submds.mds
###################################

my $mds_name_sub_mds = "$mds_name.sub.mds";

unless ($sep_pca) {
    unless ($result_name){
	if ($mds_cols eq "ALL") {
	    &mysystem ("cp $mds_name_sub $mds_name_sub_mds");
	}
	if ($mds_name ne "NOMDS") {
	    unless (-e $mds_name_sub_mds) {
		die $!." <$mds_name>" unless open MDSI, "< $mds_name";
		die $! unless open MDSO, "> $mds_name_sub_mds";
		
		my @mds_arr = split ',' ,$mds_cols;
		#print "@mds_arr\n";
		my $line = <MDSI>;
		my @cells = &split_line($line);
		
		print MDSO "$cells[0]";
		print MDSO "\t$cells[1]";
		
		foreach (@mds_arr){
		    die "wrong mds-number" if ($_ < 1);
		    my $cn = $_+2;
		    print MDSO "\t$cells[$cn]";
		}
		print MDSO "\n";
		
		while (my $line = <MDSI>){
		    my @cells = &split_line($line);
		    
		    print MDSO "$cells[0]";
		    print MDSO "\t$cells[1]";
		    
		    foreach (@mds_arr){
			my $cn = $_+2;
			print MDSO "\t$cells[$cn]";
		    }
		    
		    print MDSO "\n";
		}
		
		
		close MDSI;
		close MDSO;
	    }
	    else {
		my $submds_age = -M $mds_name_sub_mds;
		die "submds is older than mds-file" if ($submds_age > $mds_age);
	    }
	}
    }
}




#print "sleep\n";
#sleep(5);


#exit;
#exit;

###################################
###################################
### POSTIMPUTATION
###################################
###################################


$outname = $outname."_".$addout if ($addout);
$outname = $outname."_perm".$siperm if ($siperm);



my $danerjobdir = "$rootdir/danerjobdir_$outname";

unless (-e $danerjobdir){
    print "danerjobdir is not existing, create one for you\n" if ($debug);
    my @created = mkpath(   ## $created ?
			    $danerjobdir,
			    {verbose => 0, mode => 0750},
	);
}





my $danerdir = "$rootdir/daner_$outname";
my $resdandir = "$rootdir/resdaner";
my $danscoredir = "$rootdir/danscore_$outname";
my $danscoredirsum = "$danscoredir/dsc_sum";
my $danpermdir = "$rootdir/danperm_$outname";
my $dametadir = "$rootdir/dameta_$outname";
my $reportdir = "$rootdir/report_$outname";
my $distdir = "$rootdir/distribution/$outname";
my $daner_all = "daner_$outname.gz";
my $daner_all_het = "daner_$outname.het.gz";
my $daner_all_nogz = "daner_$outname";
my $daner_meta_pf = "daner_$outname";
my $daner_meta = "$daner_meta_pf.meta.gz";
my $daner_meta_nogz = "$daner_meta_pf.meta";


unless ($danscore_file ne "") {
    my @created = mkpath(   ## $created ?
			    $reportdir,
			    {verbose => 0, mode => 0750},
	);
}

if ($danscore_file ne "") {
    my @created = mkpath(   ## $created ?
			    $danscoredir,
			    {verbose => 0, mode => 0750},
	);
    if ($bgscore) {
	unless (-e $bgdir) {
	    print "Error: no best guess directory ($bgdir) found\n";
	    exit;
	}
    }
}

if ($danscore_file ne "") {
    my @created = mkpath(   ## $created ?
			    $danscoredirsum,
			    {verbose => 0, mode => 0750},
	);
}
    
my @created = mkpath(   ## $created ?
			$distdir,
			{verbose => 0, mode => 0750},
    );


unless ($danscore_file ne "") {
    my @created = mkpath(   ## $created ?
			    $dametadir,
			    {verbose => 0, mode => 0750},
	);
}

#my @created = mkpath(   ## $created ?
#			$danerdir,
#			{verbose => 0, mode => 0750},
#    );


if ($gmodel == 1) {
    $danerdir .= "_dom";
}
elsif ($gmodel == 2) {
    $danerdir .= "_rec";
}
elsif ($gmodel == 3) {
    $danerdir .= "_het";
}



#exit;

#if ($pheno_file eq "NOPHENO") {
#    unless ($nocon){#
#	print "no pheno file and not --nocon do not work yet\n";
#	exit;
#    }
#}

###################################
### check bimfli-files
###################################
my @bimfli_files_tmp;
my %mds_ids;
my %pheno_ids;
my %idin_ids;

my $clu_out_file = "$outname.$daner_all_nogz.clumped.xmhc.gz";
if ($polyfrom_file ne "") {
    if ($polyto_file eq "") {
	print "no polyto-file\n";
	exit;
    }
    unless (-e "$rootdir/$clu_out_file") {
	$pheno_file = $polyfrom_file;
    }
    else {
	$pheno_file = $polyto_file;
	$danscore_file = $clu_out_file;
    }
}

if ($polyto_file ne "") {
    if ($polyfrom_file eq "") {
	print "no polyfrom-file, please use pheno instead of poyto\n";
	exit;
    }
}

#print "bf: @bimfli_files\n";
#print "sleep\n";
#sleep(10);

unless ($sep_pca) {
    unless ($result_name){
	
	if ($mds_name ne "NOMDS") {
	    die $!." <$mds_name>" unless open MDSI, "< $mds_name";
	    while (my $line = <MDSI>){
		my @cells = &split_line($line);
		$mds_ids {"$cells[0]\t$cells[1]"} = 1;
	    }
	    close MDSI;



	    foreach my $bf (@bimfli_files) {
		my $bfile = $bf;
		$bfile =~ s/.bim$//;
		my $famfile_loc = "$bfile.fam";

		my $bfile_root = $bfile;
		$bfile_root =~ s/.$build_txt.ch.fl$//;
		#	    print "bfile: $bfile\n";
		#	    print "bfile_old: $bfile_old\n";

		my $found = 0;

		#	    print "$bfile\n";
		#	    sleep(1);

		if (exists $trioset_bimfli{$bf}){
		    push @bimfli_files_tmp, $bf;
		    print "$bf as trio, so not checked for IDs\n" if ($debug);
		    next;
		}

		#	    exit;
		#	    my $famloc = "$impute_dir/$famfile_loc";
		my $famloc = $famfile_loc;
		$famloc =~ s/$build_txt.ch.fl.fam$/fam/;
		$famloc =~ s/ch.fl.fam$/fam/;
		

		
		die $!." <$famloc>" unless open IN, "< $famloc";
		while (my $line = <IN>){
		    my @cells = &split_line($line);
		    if (exists $mds_ids{"$cells[0]\t$cells[1]"}) {
			push @bimfli_files_tmp, $bf;
			$found = 1;
			last;
		    }
		}
		close IN;
		if ($found == 0) {
		    print "this fam-file without any IDs in analysis (--mds): ".$bf."\t".$famloc."\n" ;
		}
	    }
	    
	    @bimfli_files = @bimfli_files_tmp;
	    @bimfli_files_tmp = ();
	}

	if ($pheno_file ne "NOPHENO") {
	    die $!." <$pheno_file>" unless open MDSI, "< $pheno_file";
	    while (my $line = <MDSI>){
		my @cells = &split_line($line);
		my $c0 = $cells[0];
		$c0 =~ s/.*\*// if ($strip_pt);
		my $c1 = $cells[1];
		
		if (@cells < 3) {
		    print "Error: ($0,$1) has no phenotype defined in ($pheno_file)\n";
		    print "There might be even more\n, please make sure, $pheno_file contains only three column entries\n, if you want to drop an individual, please drop the full row\n";
		}

		#	    print "triio_debug\n";
		#	    exit;
		#	    if ($trio){

		#	    }
		$pheno_ids {"$c0\t$c1"} = 1;

		### this here is strange trio-naming
		$c1 =~ s/.ca$//;
		$pheno_ids {"$c0\t$c1"} = 1;
	    }
	    close MDSI;


	    foreach my $bf (@bimfli_files) {
		my $bfile = $bf;
		$bfile =~ s/.bim$//;
		my $famfile_loc = "$bfile.fam";
		my $found = 0;

		if (exists $trioset_bimfli{$bf}){
		    push @bimfli_files_tmp, $bf;
		    print "$bf as trio, so not checked for IDs\n";
		    next;
		}

		my $bfile_root = $bfile;
		$bfile_root =~ s/.$build_txt.ch.fl$//;


		#	    my $famloc = "$impute_dir/$famfile_loc";
		my $famloc = $famfile_loc;
		$famloc =~ s/$build_txt.ch.fl.fam$/fam/;
		$famloc =~ s/ch.fl.fam$/fam/;


		die $!." <$famloc>" unless open IN, "< $famloc";
		while (my $line = <IN>){
		    my @cells = &split_line($line);
		    my $c0 = $cells[0];
		    $c0 =~ s/.*\*// if ($strip_pt);
		    if (exists $pheno_ids{"$c0\t$cells[1]"}) {
			push @bimfli_files_tmp, $bf;
			$found = 1;
			last;
		    }

		}
		close IN;
		if ($found == 0) {
		    print "this fam-file without any IDs in analysis (--pheno): ".$bf."\n";
		}
	    }
	    
	    @bimfli_files = @bimfli_files_tmp;
	    @bimfli_files_tmp = ();
	}


	if ($idin_name) {
	    die $!." <$idin_name>" unless open IDIN, "< $idin_name";
	    while (my $line = <IDIN>){
		my @cells = &split_line($line);
		my $c0 = $cells[0];
		$c0 =~ s/.*\*// if ($strip_pt);
		my $c1 = $cells[1];
		#	    print "triio_debug\n";
		#	    exit;
		#	    if ($trio){

		#	    }
		$idin_ids {"$c0\t$c1"} = 1;

		### this here is strange trio-naming
		$c1 =~ s/.ca$//;
		$idin_ids {"$c0\t$c1"} = 1;
	    }
	    close IDIN;


	    foreach my $bf (@bimfli_files) {
		my $bfile = $bf;
		$bfile =~ s/.bim$//;
		my $famfile_loc = "$bfile.fam";
		my $found = 0;

		if (exists $trioset_bimfli{$bf}){
		    push @bimfli_files_tmp, $bf;
		    print "$bf as trio, so not checked for IDs\n";
		    next;
		}

		my $bfile_root = $bfile;
		$bfile_root =~ s/.$build_txt.ch.fl$//;


		#	    my $famloc = "$impute_dir/$famfile_loc";
		my $famloc = $famfile_loc;
		$famloc =~ s/$build_txt.ch.fl.fam$/fam/;
		$famloc =~ s/ch.fl.fam$/fam/;


		die $!." <$famloc>" unless open IN, "< $famloc";
		while (my $line = <IN>){
		    my @cells = &split_line($line);
		    my $c0 = $cells[0];
		    $c0 =~ s/.*\*// if ($strip_pt);
		    if (exists $idin_ids{"$c0\t$cells[1]"}) {
			push @bimfli_files_tmp, $bf;
			$found = 1;
			last;
		    }

		}
		close IN;
		if ($found == 0) {
		    print "this fam-file without any IDs in analysis (--idin): ".$bf."\n";
		}
	    }
	    
	    @bimfli_files = @bimfli_files_tmp;
	    @bimfli_files_tmp = ();
	}

    }
}
#exit;


#my @tmp = keys %mds_ids;
#print "number mds_ids:".@tmp."\n";
#print "sleep\n";
#sleep(10);



###################################
### prepare CDG
###################################
my %cdg_dis;
my %dadimeta_bimfli_files = ();

## no CDG for now
if ($metaset_file) {
foreach (@bimfli_files) {
    my $bfile = $_;
    $bfile =~ s/.bim$//;
#    die "$impute_dir/$bfile.fam: ".$! unless open FILE, "< $impute_dir/$bfile.fam";
#    my $line = <FILE>;
#    close FILE;
#    my @starr = split '_' ,$line;
#    die "something wrong with $impute_dir/$bfile.fam" if ($starr[1] eq "");
#    $cdg_dis{$starr[1]} .= "!!$bfile";
#    push @ {$dadimeta_bimfli_files {$starr[1]}}, "$bfile";

    die "$bfile not in metaset" unless exists ($metaset{$bfile});
    my $mname = $metaset{$bfile};

    $cdg_dis{$mname} .= "!!$bfile";
    push @ {$dadimeta_bimfli_files {$mname}}, "$bfile";
}
}



my $n_cdg = keys %cdg_dis;
#my @daner_dicoll;
if ($n_cdg > 1) {
    foreach my $cx (keys %cdg_dis) {
	print "dis: $cx\n" if ($debug); 
	my $dadimetadir = $dametadir."_$cx";
	
	my @created = mkpath(   ## $created ?
				$dadimetadir,
				{verbose => 0, mode => 0750},
	    );

    }
}




#exit;


###################################
### dan-ANALYSIS
###################################



chdir($danerjobdir);

my $co_str = "";
my $pheno_str = "";
my $idex_str = "";
my $idin_str = "";
my $addcov_str = "";


unless ($sep_pca) {
    unless ($result_name) {
	if ($mds_name ne "NOMDS") {
	    if (-e $mds_name) {
		&mysystem ("rm -f $mds_name"); ## necessary since permissions do not allow for overwriting
	    }
	    &mysystem ("cp $rootdir/$mds_name .");
	    $co_str = "--mds $mds_name --coco  $mds_cols";
	}
	
	if ($pheno_file ne "NOPHENO") {
	    &mysystem ("cp $rootdir/$pheno_file .") ;
	    $pheno_str = "--pheno $pheno_file";
	}

	if ($danscore_file ne "") {
	    #	die "range file not specified" if ($range_file eq "");
	    &mysystem ("cp $rootdir/$danscore_file .") ;
	    if ($range_file eq "") {
		$range_file = "range";
		unless (-e "$rootdir/$range_file") {
		    die $! unless open RAFILE, "> $rootdir/$range_file";
		    print RAFILE "S1 0 0.00000005\n";
		    print RAFILE "S2 0 0.000001\n";
		    print RAFILE "S3 0 0.0001\n";
		    print RAFILE "S4 0 0.001\n";
		    print RAFILE "S5 0 0.01\n";
		    print RAFILE "S6 0 0.05\n";
		    print RAFILE "S7 0 0.1\n";
		    print RAFILE "S8 0 0.2\n";
		    #		print RAFILE "S7 0 0.3\n";
		    #		print RAFILE "S8 0 0.4\n";
		    print RAFILE "S9 0 0.5\n";
		    print RAFILE "S10 0 1\n";
		    close RAFILE;
		}
	    }
	    &mysystem ("cp $rootdir/$range_file .") ;
	    #	$pheno_str = "--pheno $pheno_file";
	}

	##### create a permuted phenotype-file with seed $siperm
	if ($siperm) {

	    $pheno_file = "$mds_name.perm$siperm";

	    unless (-e $pheno_file){

		print "create a permuted phenotype file\n" if ($debug);
		unless (-e $mds_name) {
		    print "permutation needs a covariate file now\n";
		    exit;
		}


		
		my @id_arr = ();
		my @pt_arr = ();
		
		die $!." <$mds_name>" unless open MDSI, "< $mds_name";
		my $header = <MDSI>;
		while (my $line = <MDSI>){
		    my @cells = &split_line($line);
		    
		    push @id_arr, "$cells[0]\t$cells[1]";
		    my $pt_loc = -9;
		    if ($cells[0] =~ /^cas_/) {
			$pt_loc = 2;
		    }
		    if ($cells[0] =~ /^con_/) {
			$pt_loc = 1;
		    }
		    push @pt_arr, $pt_loc;
		    
		}
		close MDSI;    
		srand ($siperm);
		&fisher_yates_shuffle (\@pt_arr);
		
		die $!." <$pheno_file>" unless open PO, "> $pheno_file";
		foreach my $cloc (0..$#id_arr){
		    print PO $id_arr[$cloc]."\t".$pt_arr[$cloc]."\n";
		}
		close PO;
	    }

	    $pheno_str = "--pheno $pheno_file";
	}
	
	
	if ($idex_name) {
	    &mysystem ("cp $rootdir/$idex_name .") ;
	    $idex_str = "--idex $idex_name";
	}

	if ($idin_name) {
	    &mysystem ("cp $rootdir/$idin_name .") ;
	    $idin_str = "--idin $idin_name";
	}


	if ($addcov_name) {
	    &mysystem ("cp $rootdir/$addcov_name .") ;
	    die $!."($addcov_name)" unless open FILE, "< $addcov_name";
	    my $line = <FILE>;
	    my @cells = split /\s+/, $line;
	    unless ($cells[0] eq "FID" && $cells[1] eq "IID") {
		print "Error: $addcov_name does not contain header FID IID PT....\n";
		exit;
	    }
	    
	    $addcov_str = "--addcov $addcov_name";
	}
	
    }
}

#print "co_str: $co_str\n";
#print "debug\n";
#exit;


#exit;


my @danerdir_arr = ();
my @dametacat_arr = ();
my @daner_het2p_arr = ();
my @danerdir_arr_long = ();

my @daner_mega_arr = ();
my @daner_meta_arr = ();
my @daner_dimeta_arr = ();
#my @daner_metadi_arr = ();
my @daner_files = ();
my @dameta_files = ();
my %dadimeta_files = ();
my $daner_fini_count =0;
my $daner_fini_mega_count =0;
my $daner_fini_meta_count =0;

my @danscore_arr = ();
my $danscore_neg = 0;
$danscore_neg = 1 if (-e "$rootdir/danscore_$outname"."_done");

my $n_old_format = 0;
my $n_nomap = 0;

my %bg_in;




###################################################################
############### SEP PCA
###################################################################

my %sep_covfile;
my %sep_covstr;
my $sep_idin = "$outname.menv.mds_cov";
if ($sep_idin_str) {
    $sep_idin = $sep_idin_str;
    unless (-e "$seppcadir/$sep_idin") {
	&mysystem ("ln -s $rootdir/$sep_idin $seppcadir/$sep_idin");
    }
}


if ($sep_pca) {

    
    my $mdscov_file = "$outname.covfiles";
    
    unless (-e $mdscov_file) {
	my $pcaer_count = 0;
	
	my @sep_pca_str_single;
	my @mdsfile_txt;
	my $sep_pca_str_comb = "pcaer --preferfam --prefercase --out $outname";
	
	
	unless (-e "$rootdir/daner_$outname.done") {
	    unless ($result_name){
		
		#### stuff that is done on full datasets
		foreach (@bimfli_files) {
		    
		    my $bfile = $_;

		    if (exists $trioset_bimfli{$bfile}){
			print "pre sep_pca: $bfile as trio, so no sep_pca\n";
			next;
		    }

		    my $bfile_bgs = "$bfile.bgs";
		    my $bgs_bed_source = "$bgdir/$bfile_bgs";
		    my $bgs_bed_target = "$seppcadir/$bfile_bgs";

#		    print "bgs: $bfile_bgs\n" if ($debug);
#		    print "bgs_source: $bgs_bed_source\n" if ($debug);
#		    print "bgs_target: $bgs_bed_target\n" if ($debug);
#		    exit;

		    unless (-e "$bgs_bed_target.bed") {
			print "linking $bgs_bed_source.bed to $seppcadir\n" if ($debug);
			&mysystem ("ln -s $bgs_bed_source.bed $bgs_bed_target.bed");
		    }
		    unless (-e "$bgs_bed_target.bim") {
			print "linking $bgs_bed_source.bim to $seppcadir\n" if ($debug);
			&mysystem ("ln -s $bgs_bed_source.bim $bgs_bed_target.bim");
		    }
		    unless (-e "$bgs_bed_target.fam") {
			print "linking $bgs_bed_source.fam to $seppcadir\n" if ($debug);
			&mysystem ("ln -s $bgs_bed_source.fam $bgs_bed_target.fam");
		    }

		    unless (-e "$seppcadir/$bfile.bgs.menv.trans.mds") {
			push @sep_pca_str_single, "pcaer --prefercase --out $bfile.bgs $bfile.bgs";
			print "missing (pcaer needs started): $seppcadir/$bfile.bgs.menv.trans.mds\n";
			
			$pcaer_count++;
		    }
		    else {
			unless (-e "$bfile.bgs.menv.trans.mds") {
			    unless (-e "$seppcadir/$bfile.bgs.menv.mds.overworked.p_assoc.txt") {
				print "Error: not existing: $seppcadir/$bfile.bgs.menv.mds.overworked.p_assoc.txt\n";
				exit;
			    }
			    &mysystem ("ln -s $seppcadir/$bfile.bgs.menv.trans.mds .");
			    &mysystem ("ln -s $seppcadir/$bfile.bgs.menv.mds.overworked.p_assoc.txt .");
			}

			my $pca_str = "1,2,3,4";
			
			die $!." <$bfile.bgs.menv.mds.overworked.p_assoc.txt>" unless open IN, "< $bfile.bgs.menv.mds.overworked.p_assoc.txt";
			my $npca = 0;
			while (my $line = <IN>){
			    my @cells = &split_line($line);
			    if ($npca > 4 && $cells[2] < 0.05){
				$pca_str .= ",$npca";
			    }
			    $npca++;
			}
			close IN;

			push @mdsfile_txt, "$bfile $bfile.bgs.menv.trans.mds $pca_str";
		    }
		    $sep_pca_str_comb .= " $bfile.bgs";		

		}
		
	    }

	    unless (-e "$seppcadir/$sep_idin") {
		print "###############################################################################################\n";
		print "not existing, trying to create (if present please copy it there):\n$seppcadir/$sep_idin\n";
		print "###############################################################################################\n";
		push @sep_pca_str_single, "$sep_pca_str_comb";
		print "missing (pcaer needs started): $seppcadir/$sep_idin\n";
		$pcaer_count++;
	    }
	    else {
		unless (-e "$sep_idin") {
		    print "debug1: $sep_idin\n" if ($debug);
		    &mysystem ("ln -s $seppcadir/$sep_idin .");
		    print "debug2\n" if ($debug);
		}
	    }
	}		

	if ($pcaer_count > 0) {
	    my $start_file = "start_pcaer.sh";
	    while (-e "$seppcadir/$start_file") {
		$start_file .= ".s";
	    }
	    die $! unless open FILE1, "> $seppcadir/$start_file";
	    foreach my $sep_pca_cmd (@sep_pca_str_single) {
		print FILE1 "$sep_pca_cmd\n";
	    }
	    close FILE1;

	    &mysystem ("chmod u+x $seppcadir/$start_file");
	    
	    
	    print "\n###########################################################################\n" ;
	    print "separate PCAs requested, please start these commands from the command line:\n\n" ;
	    
	    print "\tcd $seppcadir\n";
	    print "\t./$start_file\n\n";
	    print "wait till all pcaer-jobs (_pc_*) ran through and restart postimp-pipeline\n";


	    #############################################################
	    ## SUCCESSSS
	    #############################################################
	    
	    $sjadir = $rootdir;
	    $sjaname = "paused";
	    push @sjaarray, "tmp";
	    $sjatime = 2;
	    $sjamem = 1000;
	    
	    
	    &send_jobarray;

	}

	if (@mdsfile_txt == @bimfli_files) {
	    print "---------------------------------------------------------------\n" if ($debug);
	    print "Success: There are as many covariate files as there are cohorts\n" if ($debug);
	    print "---------------------------------------------------------------\n" if ($debug);
	    print "writing out mdscovfile: $mdscov_file\n" if ($debug);
	    die $! unless open FILE1, "> $mdscov_file";
	    foreach (@mdsfile_txt) {
		print FILE1 "$_\n";
	    }
	    close FILE1;
	    
	}
    }
    else {
	print "$mdscov_file exists, now going to next step\n" if ($debug);
    }
    
    die $!." <$mdscov_file>" unless open IN, "< $mdscov_file";
    while (my $line = <IN>){
	my @cells = &split_line($line);
	$sep_covfile{$cells[0]} = $cells[1];
	$sep_covstr{$cells[0]} = $cells[2];
    }
    close IN;



    my @bimfli_files_tmp2;
 #   print "nbfile: ".@bimfli_files."\n";


    die $!." <$seppcadir/$sep_idin>" unless open MDSI, "< $seppcadir/$sep_idin";
    while (my $line = <MDSI>){
	my @cells = &split_line($line);
	$mds_ids {"$cells[0]\t$cells[1]"} = 1;
    }
    close MDSI;


    
    
    foreach my $bf (@bimfli_files) {
	my $bfile = $bf;
	$bfile =~ s/.bim$//;
	my $famfile_loc = "$bfile.fam";
	my $famloc = $famfile_loc;
	$famloc =~ s/$build_txt.ch.fl.fam$/fam/;
	$famloc =~ s/ch.fl.fam$/fam/;

	if (exists $trioset_bimfli{$bfile}){
	    print "post sep_pca: $bfile as trio, so no sep_pca\n";
	    push @bimfli_files_tmp2, $bfile;
	    next;
	}

	my $found = 0;

	
	die $!." <$rootdir/$famloc>" unless open IN, "< $rootdir/$famloc";
	while (my $line = <IN>){
	    my @cells = &split_line($line);
	    if (exists $mds_ids{"$cells[0]\t$cells[1]"}) {
#		push @bimfli_files_tmp2, $bfile;
		push @bimfli_files_tmp2, $bf;
		$found = 1;
		last;
	    }
	}
	close IN;
	if ($found == 0) {
	    print "post_sep_pca this fam-file without any IDs in analysis (--mds): ".$bf."\t".$famloc."\n";
	    
	}	
	
#	if (exists $sep_covfile{$bfile}){
#
#	    print "$bfile\n";	    
#	}
    }
    @bimfli_files = @bimfli_files_tmp2;
#    print "nbfile: ".@bimfli_files."\n";


    
}



#foreach my $key (keys %sep_covfile) {

#    print "key: $key\n";
#    print "sep_covfile: $sep_covfile{$key}\n";
#    print "sep_covstr: $sep_covstr{$key}\n";
#}


#print "debug\n";
#exit;





#exit;


unless (-e "$rootdir/daner_$outname.done") {
    unless ($result_name){
	

	## walk through chunks
	foreach my $refind (@refind_arr) {
	    
	    
	    my @dasifiles = ();

#	print @bimfli_files."\n";
#	print "$refind\n";
#	exit;

	    foreach (@bimfli_files) {

		
		my $bfile = $_;

		my $co_str_loc = $co_str;
		$co_str_loc = "" if (exists $trioset_bimfli{$bfile});
#		if (exists $trioset_bimfli{$bfile}) {#
#		    print "found trio: $bfile\n";
#		}
#		print "found bfilekkjk: $bfile $co_str\n";
		
		


		$bfile =~ s/.bim$//;
		my $danerdir_loc = "$danerdir/da_$bfile";

		my $hg19_remove = 0;
		
		my $dasudir_loc = "$dasudir"."_$bfile";
		my $dasudir_loc_qc1 = "$dasudir"."qc1_$bfile";

		unless (-e $dasudir_loc_qc1) {
		    my $tmpdir = $dasudir_loc_qc1;
		    $tmpdir =~ s/.$build_txt.ch.fl/.ch.fl/;
		    if (-e $tmpdir) {
			if ($n_old_format < 100) {
			    print "found old format: $tmpdir\n" if ($debug);
			}
			$n_old_format++;
			$dasudir_loc_qc1 = $tmpdir;
			$hg19_remove = 1;
		    }
		}

#		print "$dasudir_loc\n";	
#		print "$dasudir_loc_qc1\n";
#		sleep(3);
#	    my $dasudir_loc_qc1_hg19 = "$dasudir"."qc1_$bfile";

		my $daner_out = "$danerdir_loc/dan_$bfile.$refind.assoc.dosage.ngt.gz";


#	    my $daner_out_fini = "$danerdir_loc/dan_$bfile.$refind.assoc.dosage.ngt.gz.fini";
		#### NEW!!!!!
		if (-e $daner_out) {

		    $daner_fini_count++;
		    push @dasifiles, $daner_out;
		}
		else {

		    if (-e $dasudir_loc_qc1) {
			$dasudir_loc = "$dasudir_loc_qc1/qc1";
		    }	

#		print "$dasudir_loc\n";	
#		print "$dasudir_loc_qc1/qc1\n";	

		    my $empty_file = "$bfile.$refind.empty";
		    if (exists $empty_files{$empty_file}) {
			print "empty: $empty_file\n" if ($debug);
		    }
		    else {

			my $empty_file = "$dasudir_loc/dos_$bfile.$refind.out.dosage.gz.empty";
			if (-e $empty_file) {
			    print "empty after dabg: $bfile.$refind\n" if ($debug);
			}
			else {

#		    if (-e $daner_out) {
#			$daner_fini_count++;
#		    }
#		    else {

#			    print "$daner_out\t$bfile.$refind\n";
			    my $sex_str = "";
			    if ($males) {
				$sex_str = "--males";
			    }
			    if ($females) {
				$sex_str = "--females";
			    }

			    ###################################
			    ### for sep_pca
			    ####################################
			    if ($sep_pca) {
				$idin_str = "--idin $sep_idin";
				my $sep_covfile_loc = $sep_covfile{$bfile};
				my $sep_covstr_loc = $sep_covstr{$bfile};
				$co_str_loc = "--mds $sep_covfile_loc --coco $sep_covstr_loc";
				if (exists $trioset_bimfli{$bfile}) {#
				    $co_str_loc = "";
				    $idin_str = "";
				}
						    
			    }

			    my $sys_loc = "$daner_script $sex_str --nosi --indir $dasudir_loc $idex_str $addcov_str $idin_str $pheno_str $co_str_loc --outdir $danerdir_loc $bfile.$refind";
#			    print "$sys_loc\n";
#			    exit;

			    my $mapfile = "$dasudir_loc/dos_$bfile.$refind.out.dosage.map";


#			    print "$mapfile\n";
			    if (-e $mapfile) {
#			    print "map$mapfile\n";
				if (-e "$danerdir_loc/dan_$bfile.$refind.assoc.dosage.plink_started"){
				    print "danerdir_long:" if ($debug);
				    print "\t$danerdir_loc/dan_$bfile.$refind.assoc.dosage.plink_started\n" if ($debug);

				    push @danerdir_arr_long, $sys_loc ;
				}
				else {
				    push @danerdir_arr, $sys_loc ;
				    
				    ## NEW !!!!!!
#			if (@danerdir_arr > 5000) {
#			    last;
#			}
				    
				    
				}
			    }
			    else {
				if ($n_nomap < 100) {
				    unless ($bgscore) {
					print "Warning: no map file ($mapfile)\n" if ($debug);
				    }
				}
				$n_nomap++;

			    }

			}
			
		    }
		}




		if ($danscore_neg == 0) {
#		    print "score bfile: $_, $refind\n";		
		    if ($danscore_file ne "") {
			
			my $danscoredir_loc = "$danscoredir/dsc_$bfile";
			
			if ($bgscore) {
			    
			    my $bfile_bg = "$bfile.bgn";
			    my $bg_bed = "$bgdir/$bfile_bg.bed";

			    ## for backward compatibility
			    unless (-e $bg_bed) {
				print "Warning: best_guess dataset not existing: $bg_bed\n" if ($debug);
				$bfile_bg =~ s/.ch.fl.bgn$/.bgn/;
				
				$bg_bed = "$bgdir/$bfile_bg.bed";
				unless (-e $bg_bed) {
				    print "Error: best_guess dataset not existing: $bg_bed\n";
				    exit;
				}
				
			    }
			    my $workname = "score.$bfile_bg";
			    
			    unless (exists $bg_in{$bfile_bg}) {			    
				unless (-e "$danscoredir_loc/R.$workname.hl_nw.Rin"){


				    my $sys_loc = "$daner_script --score $danscore_file --range $range_file --nosi --indir $bgdir $idex_str $addcov_str $idin_str $pheno_str $co_str_loc --outdir $danscoredir_loc --bfile $bfile_bg nouse";
				    
				    push @danscore_arr, $sys_loc;
				    print "$sys_loc\n" if ($debug);
				    print "$danscoredir_loc/R.$workname.hl_nw.Rin\n" if ($debug);
				    
				    $bg_in{$bfile_bg} = 1;
				}
			    }
			}
			else {
			    my $ident = "$bfile.$refind";
			    if ($hg19_remove) {
				$ident =~ s/.$build_txt.ch.fl/.ch.fl/;
			    }
			    
			    
			    ### getting danscore_jobs
			    unless (-e "$danscoredir_loc/dan_$ident.profile.log"){
				
				my $take = 1;
				if ($trioset_file){
				    unless (exists $trioset{$bfile}) {
					$take = 0;
				    }
				}
				
				if ($take == 1) {
				    my $mapfile = "$dasudir_loc/dos_$ident.out.dosage.map";
				    if (-e $mapfile) {
					push @danscore_arr, "$daner_script --score $danscore_file --range $range_file --nosi --indir $dasudir_loc $idex_str $addcov_str $idin_str $pheno_str $co_str_loc --outdir $danscoredir_loc $ident";
					
				    }
				    else {
					print "$mapfile not existing, maybe empty\n";
				    }
				}
			    }
			}
		    }
		}
	    }

	    if ($bgscore) {
		last;
	    }
	    
	    
	    ### META-disease
	    my @dadimeta_arr = ();
	    if ($n_cdg > 1) {
		foreach my $cx (keys %cdg_dis) {
		    
#	my @dasidifiles = grep {/\/dan_qc2report_$cx/} @dasifiles;
		    my @dasidifiles = ();
		    
		    my @tmp_arr = @{$dadimeta_bimfli_files {$cx}};
		    
		    
		    foreach my $dsf (@dasifiles){
			my $dsf_short = $dsf;
			$dsf_short =~ s!.*/dan_!!;
			$dsf_short =~ s!.$refind.assoc.dosage.ngt.gz!!;
			if ($cdg_dis{$cx} =~ /!!$dsf_short/){
			    push @dasidifiles, $dsf;
			}
		    }

		    if (@dasidifiles > 0) {
			my $dadimetadir = $dametadir."_$cx";
			my $dameta_out = "$dadimetadir/dan_$refind.assoc.dosage.meta.ngt";
			unless (-e "$dameta_out.metadaner.gz") {
			    my $sys = "$metaber_script --info_th $info_th $no_neff_filter_txt $xdf_txt --out $dameta_out @dasidifiles";
			    push @daner_dimeta_arr, $sys; 
			}
			push @ {$dadimeta_files {$cx}}, "$dameta_out.metadaner.gz";
			push @dadimeta_arr, "$dameta_out.metadaner.gz";
		    }
		}
	    }


	    if (@dasifiles > 0) {
		### META - overall
		my $dameta_out = "$dametadir/dan_$refind.assoc.dosage.meta.ngt";
		unless (-e "$dameta_out.metadaner.gz") {
		    my @dasifiles_loc = @dasifiles;
		    @dasifiles_loc = @dadimeta_arr if ($n_cdg > 1);
		    
		    
		    push @daner_meta_arr, "$metaber_script --info_th $info_th $no_neff_filter_txt $xdf_txt --out $dameta_out @dasifiles_loc";
		    #	    print "metaber5 $xdf_txt --out $dameta_out @dasifiles_loc\n";
		    #	    exit;
		}
		else {
		    $daner_fini_meta_count++;
		}
		
		my $dameta_out_short = "dan_$refind.assoc.dosage.meta.ngt";
		push @dameta_files, "$dameta_out_short.metadaner.gz";
	    }
	    
#	exit;
	    last if ($test);
	}
    }
#    print @danerdir_arr." debug\n";
#    exit;
}

#print "N dameta files: ".@dameta_files."\n";
#exit;








#print "debug\n";
#exit;


if (@danscore_arr > 0) {
    
    $sjadir = $danerjobdir;
    $sjaname = "danscore";
    $sjatime = 1;
    $sjamem = 1000;
    if ($bgscore) {
	$sjatime = 2;
	$sjamem = 4000;
    }
    @sjaarray = @danscore_arr;
    
    &send_jobarray;
}




#print "end\n";
if  ($bgscore) {


    foreach (@bimfli_files) {
	my $bfile = $_;
	$bfile =~ s/.bim$//;
	my $danscoredir_loc = "$danscoredir/dsc_$bfile";
	my $bfile_long = "score.$bfile.bgn";
	my $bfile_short = "$bfile.bgn";

	## test for backwards compatibility
	my $pdf_tmp = "$danscoredir_loc/$bfile_long.pdf";
	unless (-e $pdf_tmp) {
	    print "Warning: pdf not existing: $pdf_tmp\n" if ($debug);
	    $bfile_long =~ s/.ch.fl.bgn$/.bgn/;
	    $bfile_short =~ s/.ch.fl.bgn$/.bgn/;

	    $pdf_tmp = "$danscoredir_loc/$bfile_long.pdf";
	    unless (-e $pdf_tmp) {
		print "Error: pdf not existing: $pdf_tmp\n";
		exit;
	    }
	    
	}

	&mysystem ("cp $danscoredir_loc/$bfile_long.pdf $distdir");
	&mysystem ("cp $danscoredir_loc/$bfile_long.poly.out.txt.combined $distdir");
	&mysystem ("cp $danscoredir_loc/$bfile_long.tar.gz $distdir");
	&mysystem ("cp $danscoredir_loc/$bfile_short.fam.pt.ex $distdir");
	&mysystem ("cp $danscoredir_loc/R.$bfile_long.hl_nw.Rin $distdir");
	

    }
#    print "debug\n";
#    exit;



    #############################################################
    ## SUCCESSSS
    #############################################################
    
    $sjadir = $rootdir;
    $sjaname = "finished";
    push @sjaarray, "tmp";
    $sjatime = 2;
    $sjamem = 1000;
    
    
    &send_jobarray;



}
else {
if ($danscore_file ne "") {

    foreach (@bimfli_files) {
	my $bfile = $_;
	$bfile =~ s/.bim$//;
	my $danscoredir_loc = "$danscoredir/dsc_$bfile";
	my $npro = `ls $danscoredir_loc/*.profile | wc -l`;
	$npro = $npro * 1;
	if ($npro > 0) {
	    &mysystem ("mv -f $danscoredir_loc/*.profile $danscoredirsum");
#	    &mysystem ("mv -f $danscoredir_loc/*.log $danscoredirsum");
	}

    }

    &mysystem ("touch $rootdir/danscore_$outname"."_done");


    chdir ("$danscoredirsum");
    unless ($mds_name eq "NOMDS") {
	&mysystem ("cp $rootdir/$mds_name_sub_mds . ");
    }
    $walltime = 1;
    my $nreffiles = @refind_arr; 
    my $trio_sw = "";
    $trio_sw = "--trio" if ($trioset_file);
    my $sys = "$danscore_result_script --nref $nreffiles --out $outname --mds $mds_name_sub_mds $trio_sw";

    &mysystem ("echo $sys >> startit_job.sh") ;
#    print ("danscore_result_cmd: $sys\n") if ($debug);
#    sleep (10) if ($debug);

#    unless (-e "plot.$outname.sum.pdf") {
    unless (-e "$outname.poly.success") {


	my @dsc_arr;
	push @dsc_arr, $sys;

	$sjadir = $danscoredirsum;
	$sjaname = "dsc";
	$sjatime = 2;
	$sjamem = 5000;
	@sjaarray = @dsc_arr;
	
	&send_jobarray;




    }
    else {



#	&mysystem ("cp $outname.poly.out.txt $distdir");
	&mysystem ("tar -czf danscore_$outname.tar.gz *sumprofile");
	&mysystem ("tar -czf danscore_$outname.cov.tar.gz *sumprofile_cov");
	&mysystem ("cp danscore_$outname.tar.gz $distdir");
	&mysystem ("cp danscore_$outname.cov.tar.gz $distdir");



	
	print "copy successfull\n" if ($debug);
    }
    print "count SNPs\n" if ($debug) ;

    my $danscore_file_loc = "$danscore_file.txt";
    my $danscore_file_loc_short = "$danscore_file.txt.short";
    my $sysloc = "gunzip -c $rootdir/$danscore_file > $danscore_file_loc";
    print "$sysloc\n" if ($debug);
    &mysystem ($sysloc) unless (-e $danscore_file_loc);


    die $! unless open IN, "< $danscore_file_loc";
    die $! unless open OUT, "> $danscore_file_loc_short";
    while (my $line = <IN>){
	$line =~ s/^[\s]+//g;
	my @cells=  split /\s+/, $line;
	print OUT $cells[1];
	print OUT "\t".$cells[10]."\n";
    }
    close OUT;
    close IN;


    my $sysloc = "sort -k1,1 $danscore_file_loc_short > $danscore_file.sorted";
#    print "$sysloc\n";
    &mysystem ($sysloc) unless (-e "$danscore_file.sorted");




    #######
    #### collect the map files
    ########
    unless (-e "score.map") {
	&mysystem ("rm score.map.tmp") if (-e "score.map.tmp");
	foreach (@bimfli_files) {
	    my $bfile = $_;
	    
	    
	    my $dasudir_loc = "$dasudir"."_$bfile";
	    my $dasudir_loc_qc1 = "$dasudir"."qc1_$bfile";
	    if (-e $dasudir_loc_qc1) {
		$dasudir_loc = "$dasudir_loc_qc1/qc1";
	    }
	    
	    foreach my $refind (@refind_arr) {
		my $ident = "$bfile.$refind";
		my $mapfile = "$dasudir_loc/dos_$ident.out.dosage.map";
		&mysystem ("cat $mapfile | cut -f 2 -d \" \" >> score.map.tmp") if (-e $mapfile);
	    }

	}
	&mysystem ("mv score.map.tmp score.map");
	
    }

    my $sysloc = "sort -k1,1 score.map | uniq > score.map.sorted";
    &mysystem ($sysloc) unless (-e "score.map.sorted");

#    chdir ($distdir);
#    $sysloc = "join $refdir/$suminfo_s $danscore_file.sorted | cut -f 1,10 -d \" \" | sort -k2,2g > $danscore_file.sorted.inref.sorted";
    $sysloc = "join score.map.sorted $danscore_file.sorted | cut -f 1,2 -d \" \" | sort -k2,2g > $danscore_file.sorted.inref.sorted;";
    print "$sysloc\n" if ($debug);
    &mysystem ($sysloc) unless (-e "$danscore_file.sorted.inref.sorted");



    my @nbin;
#    my @pth = qw /0.0001 0.001 0.01 0.05 0.1 0.2 0.3 0.4 0.5 1.0/;
    my @pth = qw /0.00000005 0.000001 0.0001 0.001 0.01 0.05 0.1 0.2 0.5 1.0/;

#    print "read sorted\n";
	    
    die $!." <$danscore_file.sorted.inref.sorted>" unless open MS, "< $danscore_file.sorted.inref.sorted";
#    my $header = <MS>;
    while (my $line = <MS>){
	my @cells = &split_line($line);
	my $cc = 0;
	foreach my $pth_loc (@pth){
	    next if (($cells[1]*1) ==0);
	    if ($cells[1] < $pth_loc) {
		$nbin[$cc]++;
	    }
	    $cc++;
	}
    }
    close MS;

#    print "write nbin\n";

    my $cc = 0;
    die $! unless open FILE, "> plot.$outname.sum_all.nbin";
    print FILE "NBIN\n";
    foreach my $pth_loc (@pth){
	if ($nbin[$cc] == 0){
	    $nbin[$cc] = "0";
	}
	print FILE "$nbin[$cc]\n";
	$cc++;
    }
    close FILE;


    &mysystem ("paste plot.$outname.sum_all.nbin $outname.poly.out.txt > $outname.poly.out.txt.combined");

    &mysystem ("cp $outname.poly.out.txt.combined $distdir");
    &mysystem ("cp $outname.pdf $distdir");


    #############################################################
    ## SUCCESSSS
    #############################################################
    
    $sjadir = $rootdir;
    $sjaname = "finished";
    push @sjaarray, "tmp";
    $sjatime = 2;
    $sjamem = 1000;
    
    
    &send_jobarray;

    
    exit;
}
}


#exit;

if (@danerdir_arr > 0) {
    
    $sjadir = $danerjobdir;
    $sjaname = "daner";
    $sjatime = 2;
    $sjamem = 1000;
    @sjaarray = @danerdir_arr;
    
    &send_jobarray;
}

#exit;
if (@danerdir_arr_long > 0) {
    
    $sjadir = $danerjobdir;
    $sjaname = "danerlong";
    $sjatime = 2;
    $sjaweek = 1;
    $sjamem = 16000;
    @sjaarray = @danerdir_arr_long;
    
    &send_jobarray;
}



if (@daner_dimeta_arr > 0) {
    
    $sjadir = $danerjobdir;
    $sjaname = "dadimeta";
    $sjatime = 2;
    $sjamem = 1000;
    @sjaarray = @daner_dimeta_arr;
    
    &send_jobarray;
}




if (@daner_meta_arr > 0) {
    
    $sjadir = $danerjobdir;
    $sjaname = "dameta";
    $sjatime = 2;
    $sjamem = 1000;
    @sjaarray = @daner_meta_arr;
    
    &send_jobarray;
}







&mysystem ("touch $rootdir/daner_$outname.done");
print "daner done\n" if ($debug);

#exit;

###################################
### Permutation
###################################

if ($permut) {

    my @daner_perm = ();

    foreach my $refind (@refind_arr) {


	my $daner_out = "$danpermdir/dan_$refind.assoc.dosage.ngt.gz";
	push @daner_perm, "$daner_script --indir $dasudir $idex_str $idin_str $pheno_str $co_str --outdir $danpermdir --perm $permut $refind" unless (-e $daner_out);

    }



    if (@daner_perm > 0) {
	&a2filenew ("danperm_job_list_$outname", @daner_perm);
	my $nda = @daner_perm;
#    $walltime = $walltime +2;
#    exit;
	&mysystem ("cat danperm_job_list_$outname | $blueprint_script --njob $job_bn_th -b \"prefix\" --wa $walltime -j --na danperm_$outname");
#    &mysystem ("cat danperm_job_list_$outname | blueprint --njob $job_bn_th -b \"prefix\" --wa $walltime -j --i 8,7 --na danperm_$outname");
	&reinvo_b ("danperming_$nda","$danerjobdir/blueprint_joblist_file-danperm_$outname");
    }
    else {
	print "danperm done\n";
    }



}



chdir($rootdir);



###################################
### collecting results
###################################


my @daner_cdg_coll;
my @daner_collect;
my @daner_collect_si;


push @daner_cdg_coll, $daner_all;
push @daner_collect, $daner_all;


my @chunker_arr = ();
my @result_meta_arr = ();

my @daner_chunkdirs;
push  @daner_chunkdirs,$dametadir;


######################################
##  here without with result files#
#########################################

unless ($result_name){
    print "bimfli_files:\n" if ($debug);
    foreach (@bimfli_files) {
	print "$_\n" if ($debug);
	my $bfile = $_;
	$bfile =~ s/.bim$//;
	my $danerdir_loc = "$danerdir/da_$bfile";
	push  @daner_chunkdirs,$danerdir_loc;
    }
    print "\n";
}



######################################
##  here beginning with result files#
#########################################

unless (-e "$rootdir/resmeta_$outname.done") {
    if ($result_name){

	chdir ($reportdir);
	my @result_files ;

	die "$rootdir/$result_name: ".$! unless open FILE, "< $rootdir/$result_name";
	while (my $line = <FILE>){
	    chomp($line);
	    push @result_files, $line;
	    push @daner_collect, $line;
	    unless (-e "$rootdir/$line") {
		print "Error: $rootdir\n";
		print "Error: $line\n";
		print "Error: <$rootdir/$line> is not existing as a daner-file\n";
		print "please check $result_name, maybe an empty line in there?\n";
		print "exiting now\n";
		exit;
	    }
	    &mysystem ("$linksub_script $rootdir/$line") unless (-e $line);
	}
	close FILE;

	my %refc;
	my $rf_count_max = 0;
	
	foreach my $rf (@result_files) {
	    $rf =~ s/.gz$//;
	    my $outdir = "$resdandir/".$rf;
	    push  @daner_chunkdirs,$outdir;

	    unless (-e $outdir) {
		print "create $outdir\n" if ($debug);
		&mysystem("mkdir -p $outdir");
	    }
	    unless (-e "$outdir/$rf.gz") {
		print "create link\n" if ($debug);
		chdir ($outdir);
		&mysystem("$linksub_script $reportdir/$rf.gz");
		chdir ($reportdir);
	    }
	    my $ff = "$outdir/$rf.chunked";
	    unless (-e $ff) {
		my $Xchr_txt = "";
		if ($Xchr){
		    $Xchr_txt = "--Xchr";
		}
		my $sys = "$chunker_script $Xchr_txt --workdir $outdir $rf.gz";
		print "$sys\n" if ($debug);
		push @chunker_arr, $sys;
	    }
	    else {
		my $fc = "$outdir/$rf.count";
		unless (-e "$outdir/$rf.count") {
		    print "----------------------------------------------\n";
		    print "Error: $outdir/$rf.count\ndoes not exist,\nplease remove $outdir\nand rerun pipeline\n";
		    print "----------------------------------------------\n";
		    exit;
		}
		print "read $fc\n" if ($debug);
		my $rf_count = 0;
		die $!."$fc" unless open FILE, "< $fc";
		while (my $line = <FILE>){
		    my @cells = @{&split_line_ref(\$line)};
		    $refc{$cells[0]} .= " $outdir/$cells[1].gz";
		    $rf_count++;
		}
		close FILE;
		if ($rf_count == 0) {
		    print "----------------------------------------------\n";
		    print "Error: $outdir/$rf.count\nhas no entries,\none likely possibility is a misformatted daner file (please compare with website and doublecheck the order of the columns)\nthen remove directory $outdir\nand rerun pipeline\n";
		    print "----------------------------------------------\n";
		    exit;
		}
		if ($rf_count_max == 0) {
		    $rf_count_max = $rf_count;
		}
		else {
		    if ($rf_count_max - $rf_count > 5) {
			print "----------------------------------------------\n";
			print "Error: $outdir/$rf.count\nhas not enough entries ($rf_count_max, $rf_count),\nplease remove $outdir\nand rerun pipeline, check other count files as well\n";
			print "----------------------------------------------\n";
			exit;
		    }
		    if ($rf_count_max - $rf_count < -5) {
			print "----------------------------------------------\n";
			print "Error: $outdir/$rf.count\nhas too many entries,\nplease check other count files, maybe restart from scratch\n";
			print "----------------------------------------------\n";
			exit;
		    }	    
		
		}
	    }
	}

	foreach my $rc (keys %refc){
	    my $dameta_out = "$dametadir/dan_$rc.assoc.dosage.meta.ngt";
	    unless (-e "$dameta_out.metadaner.gz") {
		my $sys = "$metaber_script --info_th $info_th $no_neff_filter_txt $xdf_txt --out $dameta_out $refc{$rc}";
#		print "$sys\n";
#		print "debug\n";
#		exit;
		push @result_meta_arr, $sys;
		#	    print "$sys\n";
	    }
	    else {
		my $dameta_out_short = "dan_$rc.assoc.dosage.meta.ngt";
		push @dameta_files, "$dameta_out_short.metadaner.gz";
	    }
	}


	#    exit;



    }
}
else {
    die "$rootdir/$result_name: ".$! unless open FILE, "< $rootdir/$result_name";
    while (my $line = <FILE>){
	chomp($line);
	push @daner_collect, $line;
    }
    close FILE;
}



#print "debug\n";
#exit;

#if (@chunker_arr > 0) {
#    &a2filenew ("chunkres_job_list_$outname", @chunker_arr);
#    my $nda = @chunker_arr;
#    &mysystem ("cat chunkres_job_list_$outname | blueprint --njob $job_bn_th -b \"prefix\" --wa 4 -j --na chunk_$outname");
#    &reinvo_b ("chunkres_$nda","$reportdir/blueprint_joblist_file-chunk_$outname");
#}

if (@chunker_arr > 0) {
    
    $sjadir = $resdandir;
    $sjaname = "chunk";
    $sjatime = 2;
    $sjamem = 1000;
    @sjaarray = @chunker_arr;
    
    &send_jobarray;
}



#if (@result_meta_arr > 0) {
#    &a2filenew ("resmet_job_list_$outname", @result_meta_arr);
#    my $nda = @result_meta_arr;
#    &mysystem ("cat resmet_job_list_$outname | blueprint --njob $job_bn_th -b \"prefix\" --wa 0 -j --na resmet_$outname");
#    &reinvo_b ("resmeta_$nda","$reportdir/blueprint_joblist_file-resmet_$outname");
#}

if (@result_meta_arr > 0) {
    
    $sjadir = $reportdir;
    $sjaname = "resmet";
    $sjatime = 2;
    $sjamem = 1000;
    @sjaarray = @result_meta_arr;
    
    &send_jobarray;
}


&mysystem ("touch $rootdir/resmeta_$outname.done");
print "resmeta done\n" if ($debug);

chdir ($reportdir);

#print "start\n";
#foreach my $cd (@daner_chunkdirs) {
#    print "cd:$cd\n";
#}
#exit;




#####################################
## write orientation file for forest-ploter
unless (-e "danerdirs") {
    print "create file danerdirs\n" if ($debug);
    die $! unless open DD, "> danerdirs";
    foreach my $cd (@daner_chunkdirs) {
	print DD "$cd\n";
	print "putting $cd into file danerdirs\n" if ($debug);
    }
    close DD;
}
else {
    print "file danerdirs already existing\n" if ($debug);
}
#exit;

#####################################
## write directory file for each directory
foreach my $cd (@daner_chunkdirs) {
    print "CD: $cd\n" if ($debug);
    unless (-e "$cd/dirlist"){
	print "not existing: $cd/dirlist\n" if ($debug);


	opendir(DIR, "$cd") || die "can't opendir : $cd";
	my @cdfiles = readdir(DIR);
	closedir DIR;
	@cdfiles = grep (/^dan/, @cdfiles);
	@cdfiles = grep (/.gz$/, @cdfiles);
	die $! unless open CD, "> $cd/dirlist";
	foreach (@cdfiles) {
	    print CD "$_\n";
	}
	close CD;
    }
#    else {
#	print "existing: $cd/dirlist\n";
#    }
}

#print "debug\n";
#exit;



######################################
##  original pipeline with impuation#
#########################################
#else {

#    print "check daner_summing\n";

chdir ($danerdir);
    
    
#print "dameta_files: @dameta_files\n";
##### META
my @zehn = grep {/chr10_10/} @dameta_files;
if (@zehn == 0 ) {
    @zehn = @dameta_files;
}
unless (-e "$reportdir/$daner_meta") {
    unless ($cox) {   
	print "concatenate meta-results\n" if ($debug);
	if (@dameta_files == 0){
	    print "****\nError: no dameta files in list\n";
	    print "please remove daner_done:\n  $rootdir/daner_$outname.done\n";
	    print "and also resmeta_done:\n  $rootdir/resmeta_$outname.done\n";
	    print "and restart\n";
	    die;
	}
#	    print "@dameta_files\n";
#	    exit;
#	chdir ($dametadir);



#	my $sys5 = "gunzip -c $zehn[0] | head -1 | gzip -c > $reportdir/$daner_meta.tmp";
#	&mysystem ($sys5);
#	my $sys6 = "gunzip -c @dameta_files | grep -v SNP | gzip -c >> $reportdir/$daner_meta.tmp";
#	&mysystem ($sys6);

#	my $sys6 = "mv $reportdir/$daner_meta.tmp $reportdir/$daner_meta";

	my $sys_loc = "$damecat_script $dametadir $reportdir/$daner_meta @dameta_files";
	push @dametacat_arr, $sys_loc;

#	print "$sys6\n";
#	&mysystem ($sys6);

#	chdir ($danerdir);
	
	########################################
	########   here the single chromosomes
	#########################################
	
	
    }
}



    
##### MEGA
unless ($nomega) {
    my @zehn = grep {/chr10_10/} @daner_files;
    if (@zehn == 0 ) {
	@zehn = @daner_files;
    }
    unless (-e "$reportdir/$daner_all") {
	die "error, since missing: $zehn[0]" unless (-e $zehn[0]);
	print "concatenate $zehn[0]\n" if ($debug);
#    &mysystem ("rm $zehn[0]");
	
	
	&mysystem ("gunzip -c $zehn[0] | head -1 | gzip -c > $reportdir/$daner_all");
	&mysystem ("gunzip -c @daner_files | grep -v SNP | gzip -c >> $reportdir/$daner_all");
    }
}


### META-disease
if ($n_cdg > 1) {
    foreach my $cx (keys %cdg_dis) {
	unless ($cox) {  
	    die "something wrong with disease" unless exists $dadimeta_files{$cx};
	    my @dadimeta_files_loc = @ { $dadimeta_files{$cx} } ;
	    
	    my @zehn = grep {/chr10_10/} @dadimeta_files_loc;
	    if (@zehn == 0 ) {
		@zehn = @dadimeta_files_loc;
	    }
	    unless (-e "$reportdir/$daner_meta_pf.$cx.gz") {
		print "concatenate $zehn[0]\n";
		
		### have to work on metadisease!!!!
		print "debug, work on metadisease\n";
		exit;
		my $sys_loc = "$damecat_script $danerdir $reportdir/$daner_meta_pf.$cx.gz @dadimeta_files_loc";
		push @dametacat_arr, $sys_loc;
		
	    }
	    
	    push @daner_cdg_coll, "$daner_meta_pf.$cx.gz";
	}
	
    }
}

#exit;
    
    
#    foreach (@bimfli_files) {
#	print "bifli: $_\n";
#    }
    
## single studies
unless ($result_name){
    foreach (@bimfli_files) {
	unless ($cox){
	    my $bfile = $_;
	    $bfile =~ s/.bim$//;
	    my $danerdir_loc = "$danerdir/da_$bfile";
	    chdir ($danerdir_loc) or die "no danerdir_loc";
	    my $daner_bim = "daner_$bfile.gz";
	    
	    push @daner_collect, $daner_bim;
	    push @daner_collect_si, $daner_bim;
	    
	    unless (-e "$reportdir/$daner_bim") {
		opendir(DIR, ".") || die "can't opendir .: $!";
		my @dalofiles = grep {/dan_.*assoc.dosage.ngt.gz$/} readdir(DIR);
		closedir DIR;
		my @zehn = grep {/chr10_10/} @dalofiles;
		if (@zehn == 0 ) {
		    @zehn = @dalofiles;
		}	  
		print "$zehn[0]\n" if ($debug);
		my $sys_loc = "$damecat_script $danerdir_loc $reportdir/$daner_bim @dalofiles";
		push @dametacat_arr, $sys_loc;

	    }
	    
	    
	    ########################################
	    ########   here the single chromosomes
	    #########################################
	    
	    
	}
    }
}
#} # end result_name
chdir ($danerdir);


#if (@dametacat_arr > 0) {
#    &a2filenew ("dametacat_job_list_$outname", @dametacat_arr);
#    my $nda = @dametacat_arr;
#    my $walltime = 1;
#    &mysystem ("cat dametacat_job_list_$outname | blueprint -b \"prefix\" --wa $walltime -j --na damecat_$outname");
#    &reinvo_b ("dameca_$nda","$danerjobdir/blueprint_joblist_file-damecat_$outname");
#}


if (@dametacat_arr > 0) {
    
    $sjadir = $danerjobdir;
    $sjaname = "damecat";
    $sjatime = 1;
    $sjamem = 1000;
    @sjaarray = @dametacat_arr;
    
    &send_jobarray;
}


#exit;

if ($nomega) {
    &mysystem ("ln -sf $reportdir/$daner_meta $reportdir/$daner_all");
}


##########################################################
#### exchange p and hetP column
#########################################################

unless ($nohet_sw) {
unless (-e "$reportdir/$daner_all_het") {
    unless ($cox) {   
	print "create het_p_result\n" if ($debug);
	my $sys_loc = "$danerhet2p_script $reportdir/$daner_all $reportdir/$daner_all_het";
	push @daner_het2p_arr, $sys_loc;

    }
}
}
    
if (@daner_het2p_arr > 0) {
    
    $sjadir = $danerjobdir;
    $sjaname = "daner_het2p";
    $sjatime = 1;
    $sjamem = 1000;
    @sjaarray = @daner_het2p_arr;
    
    &send_jobarray;
}



#exit;




print "daner_summing done\n" if ($debug);

chdir ($reportdir);


### outdated
if ($polyfrom_file ne "") {

    my $reinvo_file = "clump.reinvoke";
    die "$reinvo_file $!" unless open OUT, "> $reinvo_file";
    print OUT "$rootdir\n";
    print OUT "$command_line\n";
    close OUT;

#    print "are we here?\n";
#    print "$clu_out_file\n";


    unless (-e $clu_out_file) {
	my $sys = "$clumpnavi2_script --pfile $daner_all --hq_f .02 --hq_i .9 --out $outname --clu_p1 1 --clu_p2 1 --clu_window 500 --clu_r2 0.25 --refdir $refdir --reinvo $reinvo_file --sepa $sepa";
#	&mysystem($sys);
	print "clump_navi needs to run on euro directory, with clump_nav3\n";#
	print "$sys\n";#
	exit;

	&mysystem("echo $sys | $blueprint_script --njob $job_bn_th -b \"prefix\" -j --na clump_$outname");

	
	
	my $now = localtime time;
	my $message = $info_txt."\tclump\t$now";


	## should not get here, outdated
#	&a2filenew_app("$loloc/impute_dir_info",$message);

	exit;
    }
    else {
	&mysystem("cp $clu_out_file $rootdir/");
    }

    unless ("$rootdir/$clu_out_file"){
	print "very very strange\n";
	exit;
    }
    chdir ($rootdir);
    &mysystem($command_line);
#    print "$sys\n";
    exit;

}


###################################
### create empty pdf
###################################

unless (-e "placeholder.pdf"){
    &mysystem ("$placeholder_script");
}

###################################
### META Analysis
###################################


if (0) {
    my $scameta_out = "$daner_meta.pdf";
    
    unless (-e $daner_meta){
	&mysystem ("$blueprint_script --njob $job_bn_th -b \"~/plink/plink --out $daner_meta_pf --meta-analysis @daner_collect_si; gzip -f $daner_meta_pf.meta\" --wa 1 -j --di --na dameta_$outname; \n");
	&reinvo_b ("dameta","$reportdir/blueprint_joblist_file-dameta_$outname");
    }
}
    
###################################
### META Disease Groups
###################################

my @daner_meta_cdg_coll;


if (0) {
    if ($cdg) {
	my %cdg_dis;
	foreach (@daner_collect_si) {
	    my @starr = split '_' ,$_;
	    $cdg_dis{$starr[2]} = 1;
	}
	my @cdg_arr = ();    
	foreach my $cx (keys %cdg_dis) {
	    my @daner_collect_si_cx = grep {/^daner_qc2report_$cx/} @daner_collect_si;

	    my $daner_meta_pf_cx = "$daner_meta_pf"."_$cx";
	    my $daner_meta_pf_cx_gz = "$daner_meta_pf"."_$cx.meta.gz";

	    push @daner_meta_cdg_coll, $daner_meta_pf_cx_gz;
	    push @cdg_arr, "~/plink/plink --out $daner_meta_pf_cx --meta-analysis @daner_collect_si_cx; gzip -f $daner_meta_pf_cx.meta" unless (-e $daner_meta_pf_cx_gz);

#	print "$daner_meta_pf_cx\n";
#	print "$daner_meta_pf_cx_gz\n";

	}
	if (@cdg_arr > 0) {
#	print "immer noch?: @cdg_arr\n";
	    &a2filenew ("cdg_job_list", @cdg_arr);
#	exit;
	    &mysystem ("cat cdg_job_list | $blueprint_script --njob $job_bn_th -b \"prefix\" --wa 2 -j --na cdg_$outname");
	    &reinvo_b ("cdg_meta","$reportdir/blueprint_joblist_file-cdg_$outname");
	}
    }
}

#exit;
#exit;

###################################
### create daner_all if NOMEGA switched
###################################

# CHR          BP          SNP  A1  A2   N           P        P(R)      OR   OR(R)       Q       I

# CHR         SNP          BP  A1  A2   FRQ_A_2958   FRQ_U_4827    INFO      OR      SE       P   ngt
if (0) {
    if ($nomega){
	unless (-e $daner_all){
	    &mysystem ("gunzip $daner_meta");

	    die $!." <$daner_meta_nogz>" unless open IN, "< $daner_meta_nogz";
	    die $! unless open OUT, "> $daner_all_nogz";

	    while (my $line = <IN>){
		my @cells = &split_line($line);
		print OUT "$cells[0]";
		print OUT "\t$cells[2]";
		print OUT "\t$cells[1]";
		print OUT "\t$cells[3]";
		print OUT "\t$cells[4]";
		print OUT "\t-";
		print OUT "\t-";
#	    print OUT "\t$cells[5]";
#	    print OUT "\t$cells[5]";
#	    print OUT "\t$cells[11]";
		print OUT "\t-";
		print OUT "\t$cells[8]";
		print OUT "\t$cells[12]";  
		print OUT "\t$cells[6]";
		print OUT "\t-";
		print OUT "\n";
	    }
	    
	    close IN;
	    close OUT;
	    &mysystem ("gzip $daner_meta_nogz");
	    &mysystem ("gzip $daner_all_nogz");

	}
    }
}


###################################
### same for CDG
###################################


if (0){
    if ($cdg){

	foreach my $daner_meta_pf_cx_gz (@daner_meta_cdg_coll) {
	    my $daner_meta_pf_cx = $daner_meta_pf_cx_gz;
	    $daner_meta_pf_cx =~ s/.gz$//;
	    my $daner_pf_cx = $daner_meta_pf_cx."daner";
	    my $daner_pf_cx_gz = $daner_meta_pf_cx."daner.gz";

	    push @daner_cdg_coll, $daner_pf_cx_gz;

	    unless (-e $daner_pf_cx_gz){
		&mysystem ("gunzip $daner_meta_pf_cx_gz");
		
		die $!." <$daner_meta_pf_cx>" unless open IN, "< $daner_meta_pf_cx";
		die $! unless open OUT, "> $daner_pf_cx";
		
		while (my $line = <IN>){
		    my @cells = &split_line($line);
		    print OUT "$cells[0]";
		    print OUT "\t$cells[2]";
		    print OUT "\t$cells[1]";
		    print OUT "\t$cells[3]";
		    print OUT "\t$cells[4]";
		    print OUT "\t-";
		    print OUT "\t-";
#		print OUT "\t$cells[5]";
#		print OUT "\t$cells[5]";
#		print OUT "\t$cells[11]";
		    print OUT "\t-";
		    print OUT "\t$cells[8]";
		    print OUT "\t$cells[12]";  
		    print OUT "\t$cells[6]";
		    print OUT "\t-";
		    print OUT "\n";
		}
		
		close IN;
		close OUT;

		&mysystem ("gzip $daner_meta_pf_cx");
		&mysystem ("gzip $daner_pf_cx");
		
	    }
	}
    }

}

###################################
## here working area
#####################################


#1) areator_dan5

#2) read out all SNPs p < e-03 for each result - file:  zcat daner_PGC_SWE_CLO_1KG.gz | awk '$11 < 1.0e-06 || NR ==1 ' | gzip -c > daner_PGC_SWE_CLO_1KG.head6.gz

#3) from there go steps down e-04, e-05, e-06

#4) manhattan_p3:

#ripke@tin.broadinstitute.org:/psych/genetics_data/ripke/imp_sweden/1KG/meta_pgc_clo/report_PGC_SWE_CLO_1KG$ manhattan_p3 -pgene 0.00000005  --pth 0.000001 --title Manhattan-Plot --sig-gwa --cols 2,11,1,3 -areator PGC_SWE_CLOZ.1KG.clump.areator.sorted.1mhc --out test4 daner_PGC_SWE_CLO_1KG.head6.gz


###################################
## topfilter
#####################################



#print "################# debug: @daner_collect\n";
#print "##################### debug: @daner_cdg_coll\n";

my @daner_single = ();
foreach my $dc_loc (@daner_collect,@daner_cdg_coll) {
    next if ($dc_loc eq "$daner_all");
#    print "##### debug: $dc_loc\n";
   push @daner_single, $dc_loc;
}

my @lth_arr;
my $lth = 3;
my @daner_allcoll = ($daner_all,$daner_all_het,@daner_single);
if ($nohet_sw) {
    @daner_allcoll = ($daner_all,@daner_single);
}

if ($onlymeta) {

    @daner_allcoll = ($daner_all,$daner_all_het);
    if ($nohet_sw) {
	@daner_allcoll = ($daner_all);
    }
#    print "debug onlymeta\n";
## manhattan_plot --pgene 0.00000005   --title Manhattan-Plot --sig-gwa --cols 2,11,1,3 -areator daner_PGC_SCZ43_mds9.gz.p4.clump.areator.sorted.1mhc --out testb --pth 0.001 daner_PGC_SCZ43_mds9.gz.p3.gz
## shrinkpdf manhattan.testb.pdf
#    exit;
}



foreach my $dc_loc (@daner_allcoll) {
#    topfilter --th 6 --outfile test.6.gz daner_PGC_SWE.1KG.perm.meta.gz

    $lth = 3;
    my $outth3 = $dc_loc.".p$lth.gz";
    unless (-e $outth3) {
	push @lth_arr, "$topfilter_script --th $lth --outfile $outth3 $dc_loc";
    }
    else {

	my $outth7 = $dc_loc.".p_gws.gz";
	unless (-e $outth7) {
	    $lth = 4;
	    my $outth4 = $dc_loc.".p$lth.gz";
	    &mysystem("$topfilter_script --th $lth --outfile $outth4 $outth3");
	    $lth = 5;
	    my $outth5 = $dc_loc.".p$lth.gz";
	    &mysystem("$topfilter_script --th $lth --outfile $outth5 $outth4");
	    $lth = 6;
	    my $outth6 = $dc_loc.".p$lth.gz";
	    &mysystem("$topfilter_script --th $lth --outfile $outth6 $outth5");
	    $lth = -1;
	    &mysystem("$topfilter_script --th $lth --outfile $outth7 $outth6");
	}
    }
}





#if (@lth_arr > 0) {
#    &a2filenew ("lth_job_list", @lth_arr);
#    my $nlth = @lth_arr;
#    &mysystem ("cat lth_job_list | blueprint --njob $job_bn_th -b \"prefix\" --mem 1 --wa 1 -j --na lth_$outname");
#    &reinvo_b ("lth_$nlth.$lth","$reportdir/blueprint_joblist_file-lth_$outname");
#}
#else {
#    print "lth done\n";
#}


if (@lth_arr > 0) {
    
    $sjadir = $reportdir;
    $sjaname = "lth";
    $sjatime = 1;
    $sjamem = 1000;
    @sjaarray = @lth_arr;
    
    &send_jobarray;
}









###################################
### areator
###################################

my @areat_arr = ();


my $Xchr_txt = "";





#############################################################
## define gwas catalog file
##############################################################






my $prekno_txt = "";

unless (-e $prekno_file) {


    my @gwascat_files = `ls -rt $refdir/gwascatalog.*.rp.txt`;
    if (@gwascat_files > 0) {
	print "using as gwas catalog file: ".$gwascat_files[$#gwascat_files]."\n" if ($debug);
	$prekno_file = $gwascat_files[$#gwascat_files];
	chomp($prekno_file)
	    #	$prekno_txt = "--prekno $prekno_file";
    }
    else {
	$prekno_file = "$hapmap_ref_root/gwascatalog/1015b/gwascatalog.txt.ow.short.new.sorted";
    }

}

unless (-e $prekno_file) {
    
    print "Error: cannot find gwas catalog file\n";
    exit;
}


my $prekno_txt = "--prekno $prekno_file";

if ($nocatalog) {
    $prekno_txt = "--nocatalog";
}
#print "using as gwas catalog file: ".$prekno_file."\n";
#print "option: ".$prekno_txt."\n";


#sleep (3);


foreach my $dc_loc (@daner_allcoll) {
    my $infile = "$dc_loc.p3.gz";
#    my $pth_loc = 0.0001;
    my $pth_txt = "--pth 0.0001";
#    print "out: $dc_loc.p3.gz\n";
    unless (-e "$dc_loc.p4.clump.areator.sorted.1mhc.xls") {
	if (-e "$dc_loc.p4.gz.n") {
	    die $! unless open FILE, "< $dc_loc.p4.gz.n";
	    my $nloc = <FILE>;
	    chomp($nloc);
	    if ($nloc == 0) {
		$infile = "$dc_loc";
		$pth_txt = "";
		print "!!!! Warning: no pvalues under 0.0001, taking all SNPs now!!!\n";
		sleep (5);
#		$pth_loc = 2;
	    }
	    close FILE;
	}


	push @areat_arr, "$areator_script $prekno_txt $Xchr_txt --r2th $r2th --plink $pth_txt --best $infile --out $dc_loc.p4 --refdir $areat_refdir";
#	print  "$areator_script $prekno_txt $Xchr_txt --r2th $r2th --plink --pth $pth_loc --best $infile --out $dc_loc.p4 --refdir $areat_refdir\n";
    }
}
#print "$prekno_txt\n";
#exit;



if (@areat_arr > 0) {
    
    $sjadir = $reportdir;
    $sjaname = "areator";
    $sjatime = 1;
    $sjamem = 3000;
    @sjaarray = @areat_arr;
    
    &send_jobarray;
}


#print "debug\n";
#sleep(5);









#if (@areat_arr > 0) {
 #   &a2filenew ("areat_job_list", @areat_arr);
 #   my $na = @areat_arr;
 #   &mysystem ("cat areat_job_list | blueprint --njob $job_bn_th -b \"prefix\" --mem 3000 --wa 2 -j --na areat_$outname");
 #   &reinvo_b ("areator_$na","$reportdir/blueprint_joblist_file-areat_$outname");
#}
#else {
#    print "areator done\n";
#}





my $areator_all = "$daner_all.p4.clump.areator.sorted.1mhc";
my $areator_all_het = "$daner_all_het.p4.clump.areator.sorted.1mhc";


#####################################################
### regioner
#####################################################

my $areator_regplot = $areator_all.".locsorted.regplot";
my $areator_forplot = $areator_all.".locsorted.sorted.forplot";
my $wc_loc = 0;

unless (-e $areator_regplot) {
    print "will do regioner\n" if ($debug);
    my @pth_arr = qw /5.0e-08 1.0e-06 1.0e-05 1.0e-04 1.0e-03 1.0e-02 1.0e-01/;
    foreach my $pth_loc (@pth_arr) {
	my $sys_str = "$comp1mhcreg_script --out $areator_all --pth $pth_loc $areator_all";
	my $sys_str = "$comp1mhcreg_script --out $areator_all --refdir $refdir --pth $pth_loc $areator_all";
	print "$sys_str\n" if ($debug);
	&mysystem ($sys_str);
	$wc_loc = `wc -l $areator_regplot`;
	if ($wc_loc > 5) {
	    print "pth: $pth_loc\n"  if ($debug);
	    last ;
	}
	else  {
	    print "under five lines: $areator_regplot\n" if ($debug);
#	    last ;
	}
    }
}
else {
    $wc_loc = `wc -l $areator_regplot`;
}
#exit;

if ($wc_loc < 1) {
    print "no SNP meets e-04....\n" if ($debug);
    exit;
}
#exit;

#########################################
## region plots
######################################

my @areap_arr;
my @areap_files;

die "$areator_regplot: ".$! unless open FILE, "< $areator_regplot";
while (my $line = <FILE>){
    chomp($line);
    my @cells = &split_line($line);
    my $pv_loc = shift(@cells);
    my $a_outname = $cells[3];
    
    if ($pv_loc eq "0") {
	push @areap_files, "placeholder.pdf";
    }
    else {
	unless (-e "$a_outname.pdf"){

	    my $sys = "$areaplot_script $prekno_txt --dandir $dametadir --refdir $refdir  --ngt-max -1 @cells --cols 2,11,1,3,-1,12 $daner_all" ;
	    push @areap_arr, $sys;
#	    print "$sys\n";
#	    sleep (3);
	}
	else {
	    push @areap_files, "$a_outname.pdf";
	}
    }
}
close FILE;


if (@areap_arr > 0) {
    
    $sjadir = $reportdir;
    $sjaname = "areaplot";
    $sjatime = 1;
    $sjamem = 1000;
    @sjaarray = @areap_arr;
    
    &send_jobarray;
}



#########################################
## region plots, not activated yet, fills the wrong array (areap_arr)
######################################

my @regplot_arr;
my @regplot_files;
if ($regplot_file) {
    &mysystem ("cp $rootdir/$regplot_file .") unless (-e "$regplot_file");
    die "$regplot_file: ".$! unless open FILE, "< $regplot_file";
    while (my $line = <FILE>){
	chomp($line);
	my @cells = &split_line($line);
	my $pv_loc = shift(@cells);
	my $a_outname = $cells[3];
	unless (-e "$a_outname.pdf"){
	    push @areap_arr, "$areaplot_script $prekno_txt --dandir $dametadir --refdir $refdir  --ngt-max -1 @cells --cols 2,11,1,3,-1,12 $daner_all" ;
	}
	else {
	    push @regplot_files, "$a_outname.pdf";
	}
    }
    close FILE;
    
    
    if (@regplot_arr > 0) {
	
	$sjadir = $reportdir;
	$sjaname = "regplot";
	$sjatime = 1;
	$sjamem = 1000;
	@sjaarray = @regplot_arr;
	
	&send_jobarray;
    }
}


#print "$areator_forplot\n";
#print "$areator_all_het\n";
#exit;

########################################
## forest plots
##############################################

my @forestp_arr;
my @forestp_files;
die "$areator_forplot: ".$! unless open FILE, "< $areator_forplot";
while (my $line = <FILE>){
    chomp($line);
    my @cells = &split_line($line);
#    my $pv_loc = shift(@cells);
    my $f_outname = $cells[7];

#    print "forest_$f_outname.pdf\n";

    unless (-e "forest_$f_outname.pdf"){
	push @forestp_arr, "$forestplot_script --meta $daner_meta @cells --danerdirs danerdirs";

    }
    push @forestp_files, "forest_$f_outname.pdf";
}
close FILE;


##########################################
## forest plots for het
#########################################

#my @forestp_arr;
my @forestphet_files;
unless ($nohet_sw){

die "$areator_all_het: ".$! unless open FILE, "< $areator_all_het";

my $line = <FILE>;
while (my $line = <FILE>){
    chomp($line);
    my @cells = &split_line($line);

# forest_plot6 --meta daner_PGC_SCZ52_0513a.malfem.meta.gz --chr 2 --pos 200825237 --snp chr2_200825237_I --out daner_PGC_SCZ52_0513a.malfem.gz.p4.clump.areator.sorted.1mhc.13.chr2_200825237_I --danerdirs danerdirs
## SNP CHR BP P OR SE A1A2 FRQ_A_35418 FRQ_U_45866 INFO Dir
##  0   1   2  3  4 5 6     7           8          9     10

#    my $pv_loc = shift(@cells);
    my $f_outname = $cells[7];
    my $chr_loc = $cells[1];
    my $pos_loc = $cells[2];
    my $snp_loc = $cells[0];
    my $pva_loc = $cells[3];
    my $out_loc = "$areator_all_het.$snp_loc";
    last if ($pva_loc >1.0e-05);
#    print "forest_$f_outname.pdf\n";

    unless (-e "forest_$out_loc.pdf"){
	push @forestp_arr, "$forestplot_script --meta $daner_meta --chr $chr_loc --pos $pos_loc --snp $snp_loc --out $out_loc  --danerdirs danerdirs";

    }
    push @forestphet_files, "forest_$out_loc.pdf";
}
close FILE;

}

#print "forest_debug\n";
#exit;

if (@forestp_arr > 0) {
    
    $sjadir = $reportdir;
    $sjaname = "forestplot";
    $sjatime = 1;
    $sjamem = 1000;
    @sjaarray = @forestp_arr;
    
    &send_jobarray;
}

my $area_plot_collection = "areas.$outname.pdf";
#print "distdir/$area_plot_collection\n";
#exit;

unless (-e "$distdir/$area_plot_collection") {
    print "join area_plots\n" if ($debug);
    &mysystem ("$pdfjoin_script --quiet --rotateoversize false --outfile $area_plot_collection @areap_files");
#    &mysystem ("gzip $area_plot_collection");
    &mysystem ("cp $area_plot_collection $distdir");

}

if ($regplot_file) {
    my $regplot_collection = "areas.$regplot_file.pdf";

    unless (-e "$distdir/$regplot_collection.gz") {
	print "join reg_plots\n" if ($debug);
	&mysystem ("$pdfjoin_script --quiet --rotateoversize false --outfile $regplot_collection @regplot_files");
	&mysystem ("gzip $regplot_collection");
	&mysystem ("cp $regplot_collection.gz $distdir");
	
    }
 

}

print "debug\n" if ($debug);
my $forest_plot_collection = "areas.fo.$outname.pdf";
if (@forestp_files > 0) {
    print "debug2\n" if ($debug);
    unless (-e "$distdir/$forest_plot_collection") {
	print "debug3\n" if ($debug);
	print "join forest_plots\n" if ($debug);
	&mysystem ("$pdfjoin_script --quiet --rotateoversize false --outfile $forest_plot_collection @forestp_files");
#	&mysystem ("gzip $forest_plot_collection");
	&mysystem ("cp $forest_plot_collection $distdir");
	
    }
}
#sleep(10);

my $forest_plot_collection_het = "areas.fo.het.$outname.pdf";
if (@forestphet_files > 0) {
    unless (-e "$distdir/$forest_plot_collection_het.gz") {
	print "join forest_plots het\n" if ($debug);
	&mysystem ("$pdfjoin_script --quiet --rotateoversize false --outfile $forest_plot_collection_het @forestphet_files");
	&mysystem ("gzip $forest_plot_collection_het");
	&mysystem ("cp $forest_plot_collection_het.gz $distdir");
	
    }
}



#exit;


my $smallest_p;
{
    die "$areator_regplot: ".$! unless open FILE, "< $areator_all";
    my $line = <FILE>;
    $line = <FILE>;
    my @cells = @{&split_line_ref(\$line)};
    $smallest_p = $cells[3];
}

#
###################################
### qq-plot and gwa plot
###################################


my $p_gene_txt = "";
#print "$smallest_p\n";
#exit;
if ($smallest_p > 1.0e-06) {
    $p_gene_txt = "--pgene 0.00001";
}
if ($smallest_p > 1.0e-05) {
    $p_gene_txt = "--pgene 0.0001";
}
if ($smallest_p < 1.0e-30) {
    $p_gene_txt = "--pgene 0.00000005";
}


my @gwa_arr = ();
my @qq_arr = ();

push @qq_arr, "$qqplot_script --maf 0.01 --info 0.6 --title QQ-plot.maf01.info6 --cacohead -p 11 --out $outname --ceiling 12 $daner_all" unless (-e "$outname"."-qq.pdf");
unless ($nohet_sw) {
    push @qq_arr, "$qqplot_script --maf 0.01 --info 0.6 --title QQ-plot.maf01.info6.het --cacohead -p 11 --out $outname.het --ceiling 12 $daner_all_het" unless (-e "$outname.het"."-qq.pdf");
}

#push @qq_arr, "qqplot_4 --ac 100 --title QQ-plot.ac --cacohead -p 11 --out $outname --ceiling 12 $daner_all" unless (-e "$outname"."-qq.pdf");
#print "$outname"."-qq.pdf\n";
#push @gwa_arr, "gwa_plot --cols 2,11,1,3 --sig-gwa --title $outname $daner_all" unless (-e "$outname"."_gwa.pdf");
#print "manhattan.$outname.pdf\n";
#push @gwa_arr, "manhattan_plot $p_gene_txt --title Manhattan-Plot --sig-gwa --cols 2,11,1,3 -areator $outname.p4.2.areator.txt --out $outname $daner_all" unless (-e "manhattan.$outname.pdf");

my @sgwa_files = ();
foreach my $dc_loc (@daner_allcoll) {
#    print "dc_loc: $dc_loc\n";
    my $infile = "$dc_loc.p3.gz";
    unless (-e "manhattan.$dc_loc.pdf") {

	if (-e "$infile.n") {
	    die $! unless open FILE, "< $infile.n";
	    my $nloc = <FILE>;
	    chomp($nloc);
	    if ($nloc == 0) {
		$infile = $dc_loc;
		$p_gene_txt = "--pgene 0.01";
	    }
	    close FILE;
	}


	my $sys4 = "$manhattanplot_script --lastp 0.001 --pth 0.001 $p_gene_txt --title Manhattan-Plot --sig-gwa --cols 2,11,1,3 -areator $dc_loc.p4.clump.areator.sorted.1mhc --out $dc_loc $infile";
	unless (-e "manhattan.$dc_loc.pdf.empty") {
	    print "$sys4\n" if ($debug);
	    push @gwa_arr, $sys4;
	}





    }


#	if ($onlymeta) {
#  manhattan_plot --maxy 27 --pth 0.003  --pgene 0.00000005 --title Manhattan-Plot --lastp 0.001 --sig-gwa --cols 2,11,1,3 -areator daner_SCZ43_results_1KG_pgc1minus.gz.p4.clump.areator.sorted.1mhc --out daner_SCZ43_results_1KG_pgc1minus.gz.nog daner_SCZ43_results_1KG_pgc1minus.gz.p3.gz
    my $infile = "$dc_loc.p3.gz";
    my $p_gene_txt_nog = "--pth 0.001 --pgene 0.00000005 --lastp 0.001 ";
    if (-e "$infile.n") {
	die $! unless open FILE, "< $infile.n";
	my $nloc = <FILE>;
	chomp($nloc);
	if ($nloc < 5) {
	    $infile = $dc_loc;
	    $p_gene_txt_nog = "--pth 1.0 --pgene 0.01 --lastp 1.0";
	}
	close FILE;
    }


    my $m1mhcfile = "$dc_loc.p4.clump.areator.sorted.1mhc";
    my $mn_loc = 0;
    die $! unless open FILE, "< $m1mhcfile";
    while (my $line = <FILE>){
	$mn_loc++;
    }
    close FILE;

    if ($mn_loc < 2) {
	&mysystem ("touch manhattan.$dc_loc.nog.pdf.empty");
	&mysystem ("touch manhattan.$dc_loc.nog2.pdf.empty");
	print "empty: manhattan.$dc_loc.nog.pdf.empty\n" if ($debug);
    }
    
    
    unless (-e "manhattan.$dc_loc.nog.pdf") {
	my $sys4 = "$manhattanplot2_script --maxy 32  $p_gene_txt_nog --title Manhattan-Plot --sig-gwa --cols 2,11,1,3 -areator $m1mhcfile --out $dc_loc.nog $infile";
	unless (-e "manhattan.$dc_loc.nog.pdf.empty") {
	    print "$sys4\n" if ($debug);
	    push @gwa_arr, $sys4;
	}
    }
    unless (-e "manhattan.$dc_loc.nog2.pdf") {
	my $sys4 = "$manhattanplot2_script  $p_gene_txt_nog --title Manhattan-Plot --sig-gwa --cols 2,11,1,3 -areator $m1mhcfile --out $dc_loc.nog2 $infile";
	unless (-e "manhattan.$dc_loc.nog2.pdf.empty") {
	    print "$sys4\n" if ($debug);
	    push @gwa_arr, $sys4;
	}
    }

#	}
    




    if (-e "manhattan.$dc_loc.pdf") {
	push @sgwa_files, "manhattan.$dc_loc.pdf";
    }
}
#print "debu\n";
#exit;







#foreach my $dc_loc (@daner_single) {
#    push @gwa_arr, "manhattan_plot --lastp 0.0001 $p_gene_txt --title Manhattan-Plot-$dc_loc --sig-gwa --cols 2,11,1,3 -areator $dc_loc.p4.2.areator.txt --out $dc_loc $dc_loc" unless (-e "manhattan.$dc_loc.pdf");
#}


my @sqq_files = ();
### hee all qq-plots of single studies
unless ($onlymeta){
    foreach my $dc_loc (@daner_single) {
#    print "dc_loc"."-qq.pdf\n";
#    exit;
	push @qq_arr, "$qqplot_script --maf 0.01 --info 0.6  --title QQ-plot-$dc_loc.maf01.info06 --cacohead -p 11 --out $dc_loc --ceiling 12  $dc_loc" unless (-e "$dc_loc"."-qq.pdf");
#	push @qq_arr, "qqplot_4 --ac 100 --title QQ-plot-$dc_loc.ac --cacohead -p 11 --out $dc_loc --ceiling 12  $dc_loc" unless (-e "$dc_loc"."-qq.pdf");
	push @sqq_files, "$dc_loc"."-qq.pdf";
    }
}


if (0) {
    foreach (@bimfli_files) {
	my $bfile = $_;
	$bfile =~ s/.bim$//;
	
	my $daner_bim = "daner_$bfile.gz";
	
#    push @sgwa_files, "s.$outname.$bfile"."_gwa.pdf";
	push @sqq_files, "s.$outname.$bfile"."-qq.pdf";
	
	my $title_loc = $bfile;
	$title_loc =~ s/qc2report//;
	
	push @qq_arr, "$qqplot_script --ac 100 --title QQ-plot-$title_loc.ac --cacohead -p 11 --out s.$outname.$bfile --ceiling 12 $daner_bim" unless (-e "s.$outname.$bfile"."-qq.pdf");
#    push @gwa_arr, "gwa_plot --cols 2,11,1,3 --sig-gwa --title s.$outname.$bfile $daner_bim" unless (-e "s.$outname.$bfile"."_gwa.pdf");
	
    }
}


if (@gwa_arr > 0) {
    
    $sjadir = $reportdir;
    $sjaname = "manhplot";
    $sjatime = 1;
    $sjamem = 1000;
    @sjaarray = @gwa_arr;
    
    &send_jobarray;
}



#exit;
###################################
## copy manhattan plots


&mysystem ("cp manhattan.daner_$outname.gz.pdf $distdir/manhattan.v2.$outname.pdf") unless (-e "$distdir/manhattan.$outname.pdf");
unless ($nohet_sw) {
    &mysystem ("cp manhattan.daner_$outname.het.gz.pdf $distdir/manhattan.v2.$outname.het.pdf") unless (-e "$distdir/manhattan.$outname.het.pdf");
}


#exit;




###################################
## copy whole genome file and excel file

unless (-e "$distdir/$areator_all.xls"){
    &mysystem ("cp $areator_all $distdir") ;
    &mysystem ("cp $areator_all.xls $distdir") ;

}
unless ($nohet_sw) {
unless (-e "$distdir/$areator_all_het.xls"){
    &mysystem ("cp $areator_all_het $distdir") ;
    &mysystem ("cp $areator_all_het.xls $distdir") ;

}
}

&mysystem ("cp $daner_all $distdir") unless (-e "$distdir/$daner_all");
&mysystem ("cp $daner_all.p3.gz $distdir") unless (-e "$distdir/$daner_all.p3.gz");


###################################
## copy qq plots


if (@qq_arr > 0) {
    
    $sjadir = $reportdir;
    $sjaname = "qqplot";
    $sjatime = 1;
    $sjamem = 3000;
    @sjaarray = @qq_arr;
    
    &send_jobarray;
}




#if (@qq_arr > 0) {
#    &a2filenew ("qq_job_list", @qq_arr);
#    exit;
#    $jmem = $jmem + 2000;
#    &mysystem ("cat qq_job_list | blueprint --njob $job_bn_th -b \"prefix\" --wa 1 -j --na qq_$outname --mem 4000");
#    &mysystem ("cat qq_job_list | blueprint --mem $jmem -b \"prefix\" --wa $walltime -j --na qq_$outname");
#    &reinvo_b ("qq","$reportdir/blueprint_joblist_file-qq_$outname");
#}
#else {
#    print "qq done\n";
#}

print "debug2b\n" if ($debug);

&mysystem ("cp $outname"."-qq.pdf $distdir/qq.$outname.pdf") unless (-e "$distdir/qq.$outname.pdf");
unless ($nohet_sw) {
    &mysystem ("cp $outname.het"."-qq.pdf $distdir/qq.$outname.het.pdf") unless (-e "$distdir/qq.$outname.het.pdf");
}


unless (-e "manhattan.daner_$outname.gz.nog.pdf.empty") {
    unless (-e "$distdir/manhattan.nog.$outname.pdf") {
	&mysystem ("$shrinkpdf_script manhattan.daner_$outname.gz.nog.pdf") unless (-e "orig.manhattan.daner_$outname.gz.nog.pdf");
#    exit;
	&mysystem ("cp manhattan.daner_$outname.gz.nog.pdf $distdir/manhattan.nog.$outname.pdf");
    }
}
unless (-e "manhattan.daner_$outname.gz.nog2.pdf.empty") {
    unless (-e "$distdir/manhattan.nog2.$outname.pdf") {
	&mysystem ("$shrinkpdf_script manhattan.daner_$outname.gz.nog2.pdf") unless (-e "orig.manhattan.daner_$outname.gz.nog2.pdf");
	&mysystem ("cp manhattan.daner_$outname.gz.nog2.pdf $distdir/manhattan.nog2.$outname.pdf") ;
    }
}


print "debug3\n" if ($debug);
if ($gwclump) {
    chdir "$distdir";

    my $sys_tmp  = "echo $clumpnavi2_script --noindel --pfile $daner_all --hq_f .05 --hq_i .9 --out $daner_all --clu_p1 1.0 --clu_p2 1.0 --clu_window 500 --clu_r2 0.1 --refdir $areat_refdir  | $blueprint_script -b \"prefix\" --wa 4 -j --na _clumpnav_$daner_all";
    my $bsys = $sys_tmp;

    if ($serial) {
	$sys_tmp  = "$clumpnavi2_script --noindel --pfile $daner_all --hq_f .05 --hq_i .9 --out $daner_all --clu_p1 1.0 --clu_p2 1.0 --clu_window 500 --clu_r2 0.1 --refdir $areat_refdir --serial --sepa $sepa";
    }
    
    my $bsys = $sys_tmp;
    
    
    unless (-e "$daner_all.clumped.xmhc.gz") {
	
	unless ($noclumper) {
	    if (1) {

		if ($serial) {
		    &mysystem ($bsys);
		}
		else {
		    my $sys_re = "$blueprint_script -b \"$bsys\" --wa 2 --di -j  --na _cl_$daner_all";
		    &mysystem ($sys_re);
		}
		
#		&mysystem ($bsys);
	    }
	    else {
		die $!."(README.clump)" unless open CLU, ">> README.clump";
		print CLU "$bsys\n";
		close CLU;
		unless (-e "$areator_all.summary") {
		    &mysystem ("$comp1mhc_script --pth 1.0e-04 $areator_all | column -t > $areator_all.summary") ;
		}

		if ($noti == 1) {
		    
		    &mysystem ('cat '.$areator_all.'.summary | '.$mutt_script.' -s Daner_results_ready_'.$outname.'  '.$email) ;

		}
		
		&mysystem ("$sb_script manhattan.nog.$outname.pdf") ;
		&mysystem ("$sb_script $areator_all.xls") ;
		
		#	    &mysystem ("send_dropbox manhattan.nog.$outname.pdf") ;
		#	    &mysystem ("send_dropbox $areator_all.xls") ;
		
	    }
	}
    }
	
}

print "debug4\n" if ($debug);

my $numbers_file = "basic.$outname.num.xls";
unless (-e "$distdir/$numbers_file") {
    my $sys = "$numbers_script basic.$outname $daner_all @daner_single";

#    print "####################################### DEBUG ###############\n";
#    print "$sys\n";
#    print "$numbers_file\n";
#    print "####################################### DEBUG ###############\n";
#    sleep (4);

    &mysystem ($sys);
    &mysystem ("cp $numbers_file $distdir");

}



print "debug5\n" if ($debug);


if ($onlymeta) {

    unless (-e "$distdir/replic/README") {

	my $outfile = "$distdir/out.$daner_all.clumped.xmhc.gz";
#    print "$outfile\nsleep\n";
	chdir "$distdir";
#    unless (-e $outfile) {
	unless (-e "$distdir/$daner_all") {
	    &mysystem ("ln -sf $reportdir/$daner_meta $distdir/$daner_all");
	}
	

	
	unless (-e "replic/README") {
	    &mysystem ("mkdir replic") unless (-e "replic");
	    chdir ("replic");
	    
	    &mysystem ("$linksub_script $distdir/$areator_all") ;
	    &mysystem ("$linksub_script $distdir/$daner_all.p3.gz") ;
	    
	    my $repl_txt = "$replicator_script --dan --areator $areator_all --gwas $daner_all.p3.gz --format 7 --refdir $areat_refdir --index --trust --rep REPFILE --nca XXX --nco XXX";
	    
	    &mysystem ("echo $repl_txt > README") ;
	}
    }
}



print "debug6\n" if ($debug);


###################################
## copy supplementary plots

#unless (-e "$distdir/report.su.$outname.pdf.gz") {
#    &mysystem ("pdfjoin --rotateoversize false --outfile report.su.$outname.pdf @par_su_files");
#    &mysystem ("pdfnup --nup 2x2 report.su.$outname.pdf");
#    &mysystem ("gzip -f report.su.$outname-nup.pdf");
#    &mysystem ("cp report.su.$outname-nup.pdf.gz $distdir/report.su.$outname.pdf.gz");

#}


###################################
### LD_SCORE
###################################
my $ldsc_tar = "$daner_all.ldsc.tar.gz";

unless ($noldsc) {
    my @ldsc_arr = ();
    
    
    my $ldsc_fini = "$daner_all.ldsc.fini";
    push @ldsc_arr, "$ldsc_script $daner_all" unless (-e $ldsc_fini);
    
    
    if (@ldsc_arr > 0) {
	
	$sjadir = $reportdir;
	$sjaname = "ldsc";
	$sjatime = 1;
	$sjamem = 4000;
	@sjaarray = @ldsc_arr;
	
	&send_jobarray;
    }
    
    
    unless (-e "$distdir/ldsc.$daner_all.tar.gz") {
	
	
	&mysystem ("cp $daner_all.ldsc.sumstats.gz $distdir/$daner_all.ldsc.sumstats.gz");
	&mysystem ("cp ldsc.$daner_all.tar.gz $distdir/ldsc.$daner_all.tar.gz");
	
    }
}




###################################
### LAHUNT
###################################

my @lahu_arr = ();
my @lahu_pdf_arr = ();

my $laout = "$outname"."_ngt";
my $laout_pdf = "$laout"."_lama-page1.pdf";
push @lahu_pdf_arr, $laout_pdf;
push @lahu_arr, "$lahunt_script -pcol 11 --best $best_lahunt --c1 12,1 --out $laout $daner_all" unless (-e $laout_pdf);

$laout = "$outname"."_info";
$laout_pdf = "$laout"."_lama-page1.pdf";
push @lahu_pdf_arr, $laout_pdf;
push @lahu_arr, "$lahunt_script -pcol 11 --best $best_lahunt --c1 8,10 --out $laout $daner_all" unless (-e $laout_pdf);



#push @lahu_ar" unless (-e $laout_pdf);

$laout = "$outname"."_frqa";
$laout_pdf = "$laout"."_lama-page1.pdf";
push @lahu_pdf_arr, $laout_pdf;
push @lahu_arr, "$lahunt_script -pcol 11 --best $best_lahunt --c1 6,10,f --out $laout $daner_all" unless (-e $laout_pdf);

$laout = "$outname"."_frqu";
$laout_pdf = "$laout"."_lama-page1.pdf";
push @lahu_pdf_arr, $laout_pdf;
push @lahu_arr, "$lahunt_script -pcol 11 --best $best_lahunt --c1 7,10,f --out $laout $daner_all" unless (-e $laout_pdf);




$laout = "$outname"."_frqulo";
$laout_pdf = "$laout"."_lama-page1.pdf";
push @lahu_pdf_arr, $laout_pdf;
push @lahu_arr, "$lahunt_script -pcol 11 --best $best_lahunt --c1 7,40,f --out $laout $daner_all" unless (-e $laout_pdf);

unless (-e "$distdir/$laout_pdf") {
    &mysystem ("cp $laout_pdf $distdir/") if (-e $laout_pdf);
}
#print "$laout_pdf\n";
#sleep(4);


$laout = "$outname"."_chr";
$laout_pdf = "$laout"."_lama-page1.pdf";
push @lahu_pdf_arr, $laout_pdf;
push @lahu_arr, "$lahunt_script -pcol 11 --best $best_lahunt --c1 1,1 --out $laout $daner_all" unless (-e $laout_pdf);


unless ($onlymeta) {
foreach my $dc_loc (@daner_single) {
#    print "dc_loc"."-qq.pdf\n";
#    exit;

    my $daner_bim = "$dc_loc";
    my $laout = "$dc_loc"."_ngt";
    my $laout_pdf = "$laout"."_lama-page1.pdf";
    push @lahu_pdf_arr, $laout_pdf;
    push @lahu_arr, "$lahunt_script -pcol 11 --best $best_lahunt --c1 12,1 --out $laout $daner_bim" unless (-e $laout_pdf);

    $laout = "$dc_loc"."_info";
    $laout_pdf = "$laout"."_lama-page1.pdf";
    push @lahu_pdf_arr, $laout_pdf;
    push @lahu_arr, "$lahunt_script -pcol 11 --best $best_lahunt --c1 8,10 --out $laout $daner_bim" unless (-e $laout_pdf);

    $laout = "$dc_loc"."_frqa";
    $laout_pdf = "$laout"."_lama-page1.pdf";
    push @lahu_pdf_arr, $laout_pdf;
    push @lahu_arr, "$lahunt_script -pcol 11 --best $best_lahunt --c1 6,10,f --out $laout $daner_bim" unless (-e $laout_pdf);

    $laout = "$dc_loc"."_frqu";
    $laout_pdf = "$laout"."_lama-page1.pdf";
    push @lahu_pdf_arr, $laout_pdf;
    push @lahu_arr, "$lahunt_script -pcol 11 --best $best_lahunt --c1 7,10,f --out $laout $daner_bim" unless (-e $laout_pdf);

}
}
if (0) {
    foreach (@bimfli_files) {
	my $bfile = $_;
	$bfile =~ s/.bim$//;
	
	my $daner_bim = "daner_$bfile.gz";
	
	
	my $laout = "s.$outname.$bfile"."_ngt";
	my $laout_pdf = "$laout"."_lama-page1.pdf";
	push @lahu_pdf_arr, $laout_pdf;
	push @lahu_arr, "$lahunt_script -pcol 11 --best $best_lahunt --c1 12,1 --out $laout $daner_bim" unless (-e $laout_pdf);
	
	$laout = "s.$outname.$bfile"."_info";
	$laout_pdf = "$laout"."_lama-page1.pdf";
	push @lahu_pdf_arr, $laout_pdf;
	push @lahu_arr, "$lahunt_script -pcol 11 --best $best_lahunt --c1 8,10 --out $laout $daner_bim" unless (-e $laout_pdf);
	
	$laout = "s.$outname.$bfile"."_frqa";
	$laout_pdf = "$laout"."_lama-page1.pdf";
	push @lahu_pdf_arr, $laout_pdf;
	push @lahu_arr, "$lahunt_script -pcol 11 --best $best_lahunt --c1 6,10,f --out $laout $daner_bim" unless (-e $laout_pdf);
	
	$laout = "s.$outname.$bfile"."_frqu";
	$laout_pdf = "$laout"."_lama-page1.pdf";
	push @lahu_pdf_arr, $laout_pdf;
	push @lahu_arr, "$lahunt_script -pcol 11 --best $best_lahunt --c1 7,10,f --out $laout $daner_bim" unless (-e $laout_pdf);

    }
}

#if (1) {
 #   if (@lahu_arr > 0) {
#	&a2filenew ("lahu_job_list", @lahu_arr);
	
#	my $lc = @lahu_arr;
#	my $jmem_loc = $jmem * 2;
#	&mysystem ("cat lahu_job_list | blueprint --njob $job_bn_th -b \"prefix\" --mem $jmem_sm --wa 2 -j --i 8,2 --na lahu_$outname");
#	&reinvo_b ("lahunt_$lc","$reportdir/blueprint_joblist_file-lahu_$outname");
 #   }
 #   else {#
#	print "lahunt done\n";
 #   }
#}




unless ($nolahunt){
    if (@lahu_arr > 0) {
	
	$sjadir = $reportdir;
	$sjaname = "lahu";
	$sjatime = 1;
	$sjamem = 2000;
	@sjaarray = @lahu_arr;
	
	&send_jobarray;
    }
    



    if (1) {
	unless (-e "$distdir/report.qc.$outname.pdf.gz") {
	    
	    #### lahunts
	    &mysystem ("$pdfjoin_script --quiet --rotateoversize false --outfile lahunt.$outname.pdf @lahu_pdf_arr");
	    #    &mysystem ("pdfjoin --outfile lahunt.$outname.pdf @lahu_pdf_arr $scameta_out");
	    &mysystem ("$pdfnup_script --quiet --nup 2x2 lahunt.$outname.pdf");
	    
	    &mysystem ("gzip -f lahunt.$outname-nup.pdf");
	    &mysystem ("mv lahunt.$outname-nup.pdf.gz report.qc.$outname.pdf.gz");
	    &mysystem ("cp report.qc.$outname.pdf.gz $distdir");
	
	}
    }
}



if ($onlymeta){


    print "exit after onlymeta\n" ;

#############################################################
## SUCCESSSS
#############################################################

$sjadir = $rootdir;
$sjaname = "finished";
push @sjaarray, "tmp";
$sjatime = 2;
$sjamem = 1000;

    
&send_jobarray;


    exit;
}



#exit;

###################################
### pdfjoin
###################################


if (0) {
    unless (-e "$distdir/$outname.p2.2.areator.txt"){
	&mysystem ("cp $outname.p2.2.areator.txt $outname.p2.areator.xls $distdir") ;
    }
}


#if ($reparea) {
#    unless (-e "$distdir/repl.areas.wi.$outname-nup.pdf.gz") {
	#### replication areas
#	&mysystem ("pdfjoin --rotateoversize false --outfile repl.areas.na.$outname.pdf @xpar_na_files");
#	&mysystem ("pdfjoin --rotateoversize false --outfile repl.areas.wi.$outname.pdf @xpar_wi_files");
#	&mysystem ("pdfnup --nup 2x2 repl.areas.na.$outname.pdf");
#	&mysystem ("pdfnup --nup 2x2 repl.areas.wi.$outname.pdf");
#	&mysystem ("gzip -f repl.areas.na.$outname-nup.pdf");
#	&mysystem ("cp repl.areas.na.$outname-nup.pdf.gz $distdir");
#	&mysystem ("gzip -f repl.areas.wi.$outname-nup.pdf");
#	&mysystem ("cp repl.areas.wi.$outname-nup.pdf.gz $distdir");
 #   }
#}

#   print "pdfjoin --rotateoversize false --outfile report.si.$outname.pdf $outname"."-qq.pdf sqq.$outname-nup.pdf $outname"."_gwa.pdf sgwa.$outname-nup.pdf\n";
#    print "pdfjoin --outfile areas.na.$outname.pdf @par_na_files\n";

#unless (-e "$distdir/report.na.$outname.pdf.gz") {

    #### areas
#    print "join AREAS\n";
#    &mysystem ("pdfjoin --rotateoversize false --outfile areas.na.$outname.pdf @par_na_files");
#    &mysystem ("pdfjoin --rotateoversize false --outfile areas.wi.$outname.pdf @par_wi_files");
#    &mysystem ("pdfnup --nup 2x2 areas.na.$outname.pdf");
#    &mysystem ("pdfnup --nup 2x2 areas.wi.$outname.pdf");

    ##sgwas and sqq
unless (-e "$distdir/report.si.$outname.pdf.gz") {
    unless ($result_name){
	print "join SGWAS and SQQ\n" if ($debug);
	print "here single files: @sgwa_files\n" if ($debug);
	&mysystem ("$pdfjoin_script --quiet --rotateoversize false --outfile sgwa.$outname.pdf @sgwa_files");
	&mysystem ("$pdfjoin_script --quiet --rotateoversize false --outfile sqq.$outname.pdf @sqq_files");
	&mysystem ("$pdfnup_script --quiet --nup 2x2 sgwa.$outname.pdf");
	&mysystem ("$pdfnup_script --quiet --nup 2x2 sqq.$outname.pdf");

	unless ($nohet_sw) {
	    &mysystem ("$pdfjoin_script --quiet --rotateoversize false --outfile report.si.$outname.pdf $outname"."-qq.pdf $outname.het"."-qq.pdf sqq.$outname-nup.pdf manhattan.daner_$outname.gz.pdf sgwa.$outname-nup.pdf");
	}
	else {
	    &mysystem ("$pdfjoin_script --quiet --rotateoversize false --outfile report.si.$outname.pdf $outname"."-qq.pdf sqq.$outname-nup.pdf manhattan.daner_$outname.gz.pdf sgwa.$outname-nup.pdf");
	}
	&mysystem ("gzip -f report.si.$outname.pdf");
	&mysystem ("cp report.si.$outname.pdf.gz $distdir");
    }
}

#    print "join REPORT.SI\n";
#    &mysystem ("mv areas.na.$outname-nup.pdf report.na.$outname.pdf");
#    &mysystem ("mv areas.wi.$outname-nup.pdf report.wi.$outname.pdf");
#    &mysystem ("gzip -f report.na.$outname.pdf");
#    &mysystem ("gzip -f report.wi.$outname.pdf");
#    &mysystem ("cp report.na.$outname.pdf.gz $distdir");
#    &mysystem ("cp report.wi.$outname.pdf.gz $distdir");

    ## whole p-value-list


#}





## conditional collection
#unless ($nomega) {
#    unless ($nocon) {
#	unless (-e "$distdir/report.co.$outname.pdf.gz") {
#	    &mysystem ("pdfjoin --rotateoversize false --outfile report.co.$outname.pdf @par_cond_files");
#	    &mysystem ("pdfnup --nup 2x2 report.co.$outname.pdf");
#	    &mysystem ("gzip -f report.co.$outname-nup.pdf");
#	    &mysystem ("cp report.co.$outname-nup.pdf.gz $distdir/report.co.$outname.pdf.gz");
#	}
 #   }
#}
















chdir ($rootdir);
#my $pwd_loc = `pwd`;


###################
### sum process
#################################
my $performerdir = "$rootdir/performer";

unless (-e $performerdir){
    print "performer_dir is not existing, create one for you\n" if ($debug);
    my @created = mkpath(   ## $created ?
			    $performerdir,
			    {verbose => 0, mode => 0750},
	);
}





#print "sleep\n";
#sleep(4);

chdir ($distdir);
unless (-e "$areator_all.summary") {
    &mysystem ("$comp1mhc_script --pth 1.0e-04 $areator_all | column -t > $areator_all.summary") ;
}

if ($noti == 1) {
    
    &mysystem ('cat '.$areator_all.'.summary | '.$mutt_script.' -s Daner_results_ready_'.$outname.' '.$email) ;

}

#&mysystem ("$senddropbox_script manhattan.v2.$outname.pdf") ;
#&mysystem ("$senddropbox_script $areator_all.xls") ;


unless (-e "README.send_dropbox.txt") {
    my $sd_txt;
    $sd_txt .= "$senddropbox_script manhattan.v2.$outname.pdf\n";
    $sd_txt .= "$senddropbox_script manhattan.nog2.$outname.pdf\n";
    $sd_txt .= "$senddropbox_script manhattan.nog.$outname.pdf\n";
    $sd_txt .= "$senddropbox_script qq.$outname.pdf\n";
    $sd_txt .= "$senddropbox_script qq.$outname.het.pdf\n";
    $sd_txt .= "$senddropbox_script basic.$outname.num.xls\n";

    $sd_txt .= "$senddropbox_script $areator_all.xls\n";
    $sd_txt .= "$senddropbox_script $area_plot_collection\n";
    $sd_txt .= "$senddropbox_script $forest_plot_collection\n";

    unless ($noldsc) {
	$sd_txt .= "$senddropbox_script manhattan.nog.$outname.pdf\n";
    }

    $sd_txt .= "$senddropbox_script report.qc.$outname.pdf.gz\n";
    $sd_txt .= "$senddropbox_script report.si.$outname.pdf.gz\n";

    die $!."(README.send_dropbox.txt)" unless open OUT, "> README.send_dropbox.txt";
    print OUT "$sd_txt\n";
    close OUT;


}

unless (-e "replic/README") {
    &mysystem ("mkdir replic") unless (-e "replic");
    chdir ("replic");

    &mysystem ("$linksub_script $distdir/$areator_all") ;
    &mysystem ("$linksub_script $distdir/$daner_all.p3.gz") ;

    my $repl_txt = "$replicator_script --dan --areator $areator_all --gwas $daner_all.p3.gz --format 7 --refdir $areat_refdir --index --trust --rep REPFILE";

    &mysystem ("echo $repl_txt > README") ;
}







#############################################################
## SUCCESSSS
#############################################################

$sjadir = $rootdir;
$sjaname = "finished";
push @sjaarray, "tmp";
$sjatime = 2;
$sjamem = 1000;

    
&send_jobarray;




exit;



