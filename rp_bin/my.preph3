#!/usr/bin/perl

use strict;
use warnings;

#############################
# load utility functions
#############################

use FindBin;
use lib "$FindBin::Bin";
use Ricopili::Utils qw(trans);

#############################
# read config file
#############################

my $shloc = &trans("shloc");
my $p2loc = &trans("p2loc");
my $ealoc = "";

my $buffer = 1000;


###########################################
##### help message
my $usage = "
Usage : my.preph --out BFILE --in BFILE --fam FAMFILE --gema GEMAFILE --multi INT

 --out STRING      name of out-bfile
 --in STRING       name of in-bfile (will create haps and legend)
 --gema STRING     gema-file
 --fam STRING      separate famfile with short ID names
 --multi INT       multithreading
 --chrX            for X chromosome
 --spliha INT      for splitter
 --eagle           use eagle instead of shapeit
 --eaglvcf         use eagle with VCF output (suitable for Minimac3)
 --ref STRING      path to the reference vcf.gz file (required for --eagle_vcf; otherwise not used)
 --nospli          do not perform second task (splitting into smaller chunks)

 --refind          identifier for extracting chr_start_end (in Mb)
 --empty STRING    name of empty-file
 --buffer INT      buffer around refind, default $buffer
 --mendel          clean for mendel errors
 --sfile STRING    file containing SNPs to exptract


";

my $outname = "";
my $inname = "";
my $gemafile = "";
my $famfile = "";
my $multi = 0;
my $spliha = 0;
my $emptyname = "";
my $sfile = "";
my $refind = "";

use Getopt::Long;
GetOptions( 

    "out=s"=> \ $outname,
    "in=s"=> \ $inname,
    "gema=s"=> \ $gemafile,
    "fam=s"=> \ $famfile,
    "multi=i"=> \ $multi,
    "spliha=i"=> \ $spliha,
    "chrX"=> \my $chrx,
    "eagle"=> \my $eagle_sw,
    "eaglvcf"=> \my $eagle_vcf,
    "ref:s"=>\my $ref,
    "nospli"=> \my $nospli,
    "sfile=s"=> \ $sfile,
    "refind=s"=> \ $refind,
    "buffer=i"=> \ $buffer,
    "mendel"=> \my $mendel_sw,
    "empty=s"=> \ $emptyname,

    
    );

if ($outname eq "" || $inname eq ""  || $emptyname eq "" || $gemafile eq "" || !($eagle_sw || $eagle_vcf) && ($famfile eq "" || $spliha == 0)){
    print "$usage\n";
    die;
}

if ($sfile eq "" && $refind eq ""){
    print "$usage\n";
    die;
}

if ($eagle_sw or $eagle_vcf) {
    $ealoc = &trans("ealoc");
}

unless (-e "$inname.bim") {
    print "error: no $inname.bim\n";
    exit;
}


#my $shapeit_bin = "shapeit.v2.r644.linux.x86_64";
my $shapeit_bin = "shapeit.v2.r837.linux.x86_64";
#my $eagle_bin = "eagle_v2.2a";
my $eagle_bin = "eagle";



my $mendel_clean = "";
if ($mendel_sw) {
    $mendel_clean = "--set-me-missing --me 1 1";
}



my $xtxt = "";
if ($chrx) {
    $xtxt = "--chrX";
}

my $multi_txt = "";
if ($multi > 1 ) {
    $multi_txt = "--thread $multi";
    if ($eagle_sw || $eagle_vcf) {
	$multi_txt = "--numThreads=$multi";
    }
}


##########################################
# subroutine to split a plink-output-line with references
##########################################

sub split_line_ref {
    my ($line)=${$_[0]};
    chomp($line);
    $line =~ s/^[\s]+//g;
    my @cols=  split /\s+/, $line;
    \@cols;
}





if (-e "$outname.fini") {
    system ("rm $outname.fini");
}





######################
# extract chunk
##############################




my $sys = "";

if ($refind) {
    my @tcells = split /_/, $refind;
    my $kb_start = ($tcells[1])*1000 - $buffer;
    my $kb_end = ($tcells[2])*1000 + $buffer;
    
    my $chrind = $tcells[0];
    $chrind =~ s/chr//;

    $sys = "$p2loc/plink --memory 2000 --bfile $inname --out $outname --make-bed --chr $chrind --from-kb $kb_start --to-kb $kb_end $mendel_clean";
}
else {
    $sys = "$p2loc/plink --memory 2000 --bfile $inname --out $outname --make-bed --extract $sfile $mendel_clean";
}


my $sc = system ($sys);

if ($sc != 0 ) {
    print "Error with running plink: $sys\n";
    exit;
}



my $last_line = `tail -n 3 $outname.log`;

my $empty = 0;
if ($last_line =~ /Error: No variants remaining after --extract/){
    $empty = 1;
}

if ($last_line =~ /Error: All variants excluded./){
    $empty = 1;
}


my $bimcount = `wc -l $outname.bim`;
my @bc = split /\s+/, $bimcount;
if ($bc[0] < 5){
    $empty = 1;
}
#print "bimn: $bc[0]\n";
#exit;


if ($empty == 1) {
    system ("touch $emptyname");
    system ("touch $outname.fini");
    print "empty dataset detected\n";
    exit;
}



print "chunk successfully extracted\n";



system ("touch $outname.multi.$multi");


######################
# BEGIN
##############################

die $!."$outname.phase.cmd" unless open BC, "> $outname.phase.cmd";


my $sys_loc = "$shloc/$shapeit_bin --seed 123454 $xtxt --input-bed $outname.bed $outname.bim $famfile --output-max $outname.haps $outname.sample --output-log $outname.shape.log --input-map $gemafile $multi_txt > /dev/null";
#my $sys_loc = "$shloc/$shapeit_bin --seed 123454 $xtxt --input-bed $inname.bed $inname.bim $famfile --output-max $outname.haps $outname.sample --output-log $outname.shape.log --input-map $gemafile $multi_txt > /dev/null";

if ($eagle_sw or $eagle_vcf) {
    $gemafile =~ s/.txt$/.chr.txt/;
}
if ($eagle_sw) {
    $sys_loc = "$ealoc/$eagle_bin --maxMissingPerIndiv=1.0 --maxMissingPerSnp=1.0  --bfile=$outname --geneticMapFile=$gemafile --outPrefix=$outname $multi_txt > $outname.log 2> $outname.loge";
}


if ($eagle_vcf) {
    # Convert plink bfile to a vcf file, then run Eagle to obtain a phased vcf file.
    # The resulting phased vcf can then be used with Minimac3.

    unless ($ref) {
      die "$0: Please specify the reference file (e.g. --ref=my/ref.vcf.gz)\n";
    }

    my $tabix = trans("tabixloc") . "/tabix";

    # NOTE: the temporary name is 'unphased0' because Eagle itself writes a file
    # out.unphased.vcf.gz
    $sys_loc = qq{
      { $p2loc/plink --bfile "$outname" --recode vcf-iid bgz --out "$outname.unphased0" &&
        $tabix -f "$outname.unphased0.vcf.gz" &&
        $ealoc/$eagle_bin --vcfRef "$ref" --vcfTarget "$outname.unphased0.vcf.gz" --geneticMapFile=$gemafile --outPrefix=$outname $multi_txt
      } > $outname.log 2> $outname.loge
    };
}


$sc = 0;
unless (-e "$outname.first.fini"){
    print "$sys_loc\n";
    $sc = system ($sys_loc) ;
    print BC "$sys_loc\n";
}


close BC;
### right now I don't check why it fails
if (0) {
    if ($sc != 0) {
	print "something went seriously wrong\n";
	my $sys_loc = "$p2loc/plink --memory 2000  --bfile $inname --out $inname.miss --missing";
	$sc = system ($sys_loc) ;


	die $!."($inname.miss.imiss)" unless open FILE, "< $inname.miss.imiss";
	my $line = <FILE>;
	while (my $line = <FILE>){
	    my @cells = @{&split_line_ref(\$line)};
	    if ($cells[5] > .8) {
		print "-------------------------------------------------------------\n";
		print "Error: found ID with high missing rate (th = 0.8): $cells[5] @cells\n";
		system ("touch $outname.first.error");
	    }
	}
	close FILE;


	exit;
    }
}


if ($sc == 0 ) {



    unless ($nospli or $eagle_vcf) {
	if ($eagle_sw) {
	    $sys_loc = "gunzip -c $outname.haps.gz > $outname.haps";
	    $sc = system ($sys_loc) ;
	}
	system ("touch $outname.first.fini");
	my $sys_loc2 = "splithap_1 --nhaps $spliha $outname.haps";
	
	
	
	die $!."$outname.split.cmd" unless open BC, "> $outname.split.cmd";
	print BC "$sys_loc2\n";
	close BC;
    

    
	print "$sys_loc2\n";
	#    exit;
	my $sc2 = system ($sys_loc2);
	if ($sc2 == 0 ) { 
	    system ("touch $outname.fini");
	}
    }
    else {
	system ("touch $outname.fini");
	system ("rm $outname.bed");
	system ("rm $outname.bim");
	system ("rm $outname.fam");
	
    }
    
}
else {
    print "job finished with error\n";
}






